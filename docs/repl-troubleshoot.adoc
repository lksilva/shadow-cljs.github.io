# REPL Troubleshooting [[repl-troubleshooting]]

Ter um CLJS REPL funcionando bem pode ser um pouco complicado as vezes e um monte de coisas pode dar errado desde que mover todas essas partes pode ser um pouco complicado. Esse guia tem a intenção de fornecer os problemas mais comuns que as pessoas enfretam e como corrigir eles.

image::shadow-cljs-repl.png[]

## Anatomia do REPL CLJS [[cljs-repl-anatomy]]

Um REPL em Clojure faz exatamente o que o nome sugere: Ler um form, avalia ele, exibe o resultado, faz isso novamente.

Contude em ClojureScript as coisas são um pouco mais complicadas desde que a compilação acontece na JVM mas os resultados são avaliados em runtime no JavaScript. Existe um conjunto a mais de passos que precisam ser feitos com a finalidade de "emular" a experiência simples do REPL. Apesas das coisas serem implementadas um pouco diferentes com o `shadow-cljs` em comparação com o CLJS os principios básicos permanecem os mesmos.

Primeiro você vai precisar de um cliente REPL. Isso poderia ser apenas o CLI (eg. `shadow-cljs cljs-repl app`) ou no seu Editor conectado via `nREPL`. O cliente vai sempre conversar diretamente ao servidor `shadow-cljs` e ele vai manipular o resto. A partir do lado do cliente isso ainda vai parecer como um simples REPL mas existe algumas coisinhas a mais acontecendo em segundo plano.

1) Leitura: Isso tudo começa com a leitura de um único form CLJS para um determinado InputStream. Isso é um bloquei lido diretamente do `stdin` ou le a partir de uma string no caso do `nRPL`. Um Stream de caracteres são transformados em estrutura de dados, `"(+ 1 2)"` (uma string) se torna `(+ 1 2)` (uma lista).

2) Compilação: Esse form é então compilado no lado da JVM `shadow-cljs` e transformado em um conjunto de instruções.

3) Transferir Out: Essas instruções são transferidas para a runtime Javascript conectada. Isso deveria ser um Browser ou um processo `node`.

4) Eval: A runtime conectada vai pegar as instruções recebidas e `eval` elas.

5) Print: O resultado do `eval` é exibido como uma String na runtime JS.

5) Transfer Back: O resultado exibido é transferido de volta para o lado da JVM `shadow-cljs`.

6) Resposta: O lado da JVM vai encaminhar o resultado recebido de volta ao chamador inicial e o resultado e exibido para do OutputStream adequado (ou enviado como uma mensagem no nREPL).

7) Loop: Volta ao estágio 1.


## JavaScript Runtimes

The `shadow-cljs` JVM side of things will require one running `watch` for a given build which will handle all the related REPL commands as well. It uses a dedicated thread and manages all the given events that can happen during development (eg. REPL input, changing files, etc).

The compiled JS code however must also be loaded by a JS runtime (eg. Browser or `node` process) and that JS runtime must connect back to the running `shadow-cljs` process. Most `:target` configurations will have the necessary code added by default and should just connect automatically. How that connect is happening is dependent on the runtime but usually it is using a WebSocket to connect to the running `shadow-cljs` <<http, HTTP server>>.

Once connected the REPL is ready to use. Note that reloading the JS runtime (eg. manual browser page reload) will wipe out all REPL state of the runtime but some of the compiler side state will remain until the `watch` is also restarted.

It is possible for more than one JS runtime to connect to the `watch` process. `shadow-cljs` by default picks the first JS runtime that connected as the `eval` target. If you open a given `:browser` build in multiple Browsers only the first one will be used to `eval` code. Or you could be opening a `:react-native` app in iOS and Android next to each other during development. Only one runtime can eval and if that disconnects the next one takes over based on the time it connected.


## Missing JS runtime [[missing-js-runtime]]

> No application has connected to the REPL server. Make sure your JS environment has loaded your compiled ClojureScript code.

This error message just means that no JS runtime (eg. Browser) has connected to the `shadow-cljs` server. Your REPL client has successfully connected to the `shadow-cljs` server but as explained above we still need a JS runtime to actually `eval` anything.

Regular `shadow-cljs` builds do not manage any JS runtime of their own so you are responsible for running them.

### :target :browser [[repl-trouble-browser]]

For <<target-browser, `:target :browser`>> builds the `watch` process will have compiled the given code to a configured `:output-dir` (defaults to `public/js`). The generated `.js` must be loaded in a browser. Once loaded the Browser Console should show a `WebSocket connected` message. If you are using any kind of custom HTTP servers or have over-eager firewalls blocking the connections you might need to set some additional configuration (eg. via <<proxy-support, :devtools-url>>). The goal is to be able to connect to the <<http, primary HTTP server>>.


### :target :node-script, :node-library [[repl-trouble-node]]

These targets will have produced a `.js` file that are intended to run in a `node` process. Given the variety of options however you'll need to run them yourself. For example a `:node-script` you'd run via `node the-script.js` and on startup it'll try to connect to the `shadow-cljs` server. You should see a `WebSocket connected` message on startup. The output is designed to only run on the machine they were compiled on, don't copy `watch` output to other machines.

### :target :react-native [[repl-trouble-react-native]]

The generated `<:output-dir>/index.js` file needs to be added to your `react-native` app and then loaded on an actual device or emulator. On startup it will also attempt to connect to the `shadow-cljs` server. You can check the log output via `react-native log-android|log-ios` and should show a `WebSocket connected` message once the app is running. If you see a websocket related error on startup instead it may have failed to connect to the shadow-cljs process. This can happen when the IP detection picked an incorrect IP. You can check which IP was used via `shadow-cljs watch app --verbose` and override it via `shadow-cljs watch app --config-merge '{:local-ip "1.2.3.4"}'`.
