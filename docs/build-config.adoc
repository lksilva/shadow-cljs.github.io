`shadow-cljs.edn` também precisa de uma sessão de `:builds`. Builds deve ser um mapa de builds *keyed* pelo ID da build: 

.Um arquivo de configuração com um mapa da build.
```
{:dependencies [[some-library "1.2.1"] ...]
 :source-paths ["src"]
 :builds
 {:app   {:target     :browser
          ... browser-specific options ...}
  :tests {:target :karma
          ... karma-specific options ...}}}
```

Cada build descreve artefatos que o compilador vai construir. O build target é uma funcionalidade extensível do `shadow-cljs`, e o compilador já vem com algumas delas. 

== Build Target

Cada build em `shadow-cljs` deve definir um `:target` qual define onde você pretende que seu código seja executado. Existem padrões built-ins para cada <target-browser,browser>> e <<target-node,`node.js`>>. Eles também compartilham os conceitos básicos de ter os modos `:dev` e `:release`. O modo `:dev` provê todas as facilidades do desenvolvimento como compilação rápida, live reloading e a REPL. O modo `:release` vai produzir um output otimizado para produção. 

Targets é coberto em um capítulo separado

Aqui tem alguns deles:

[Horizontal]
<<target-browser, `:browser`>>:: Código de output adequado para rodar no navegador.
<<target-bootstrap, `:bootstrap`>>:: Código de output adequado para rodar em um ambiente cljs.
<<target-browser-test, `:browser-test`>>:: Examina os arquivos de testes arquivos obrigatórios, e a saída de testes adequada para rodar no navegador.
<<target-karma, `:karma`>>:: Examina os arquivos de testes arquivos obrigatórios, e uma saída de testes compatível com o  karma-runner. Mais informações http://karma-runner.github.io/2.0/index.html[Karma].
<<target-node-library, `:node-library`>>:: Saída de código adequada para usar como uma biblioteca Node.
<<target-node-script, `:node-script`>>:: Saída de código adequada para usar como um script node.
<<target-npm-module, `:npm-module`>>:: Saída de código adequada para usar como um módulo npm.

Cada target é coberto com mais detalhes no próprio capitulo desde que as opções de build remanescentes varia de acordo com o target selecionado.

== Opções de desenvolvimento [[devtools]]

Cada build `:target` tipicamente provê algum suporte de desenvolvimento. Eles são agrupado debaixo da chave `:devtools` para cada `:build`.

=== REPL

Quando rodando o `watch` o código para a REPL é injetado automáticamente e geralmente não requer configuração adicional. Opções adicionais são disponíveis para controlar o comportamento da REPL:

- `:repl-init-ns` permite configurar em qual namespace a REPL vai iniciar. O padrão é `cljs.user`.
- `:repl-pprint` faz a REPL usar `cljs.pprint` ao invés do habitual `pr-str` quando exibindo os resultados avaliados. Padrão é false.
```
{...
 :builds
 {:app {...
        :devtools {:repl-init-ns my.app
                   :repl-pprint true
                   ...}}}}
```


=== Preloads

Como desenvolvedor a maior parte do seu tempo é gasto no modo de desenvolvimento. Você provavelmente está familiarizado com as ferramentas como `figwhell`, `boot-reload`, e `devtools`. É quase certo que você quer um ou mais desses no seu processo de build.

Preload são usados para forçar certos namespaces na frente do seu Javascript gerado. Isso é geralmente usado para injetar ferramentas e intermediar antes da aplicação carregar e rodar. A opção de preload é simples, uma lista de namespaces no `:devtools`/`:preloads` na seção do `shadow-cljs-edn`: 

```
{...
 :builds
 {:app {...
        :devtools {:preloads [fulcro.inspect.preload]
                   ...}}}}
```

NOTE: Desde a versão 2.0.130 shadow-cljs automáticamente adiciona `cljs-devtools` para preloads em
`watch` e `compile` se eles estão no classpath. Tudo que precisa fazer é ter certeza de ter `cljs-devtools` no
target especifico, você pode suprimir esse comportamento adicionando `:console-support false` para o seção `:devtools`
desses targets.

=== Hot Code Reload

Os ecosistemas React e o ClojureScript combinam para fazer esse tipo de coisa super útil. O sistema `shadow-cljs`
inclue tudo que você precisa para funcionar o hot reload do código, sem precisar recorrer a ferramentas externas.

Com a finalidade de usar isso simplesmente rode:

```
shadow-cljs watch build-id
```

=== Ciclo de vida dos Hooks

É possível configurar o compilador para rodar funções antes antes do hot reload do código se transformar em código atualizado, e depois também. Eles são úteis para parar/iniciar as coisas que caso contrários, se apróxima do código antigo.

Podem ser configuradas através da sessão `:devtools` no seu arquivo de configuraçnao ou diretamente no código através dos tags metadados.

==== Metadados

É possível configurar certos metadados em CLJS `defn` para informar ao compilador que aquelas funções deveriam ser chamadas em certo momento quando estiver em live reloading.

.configuração hook via metadata
```clojure
(ns my.app)

(defn ^:dev/before-load stop []
  (js/console.log "stop"))

(defn ^:dev/after-load start []
  (js/console.log "start"))
```

Isso chamaria `my.app/stop` antes de carregar qualquer código novo e `my.app/start` quando todo o novo código for carregado. É possível também tagear multiplas funções como essa e eles serão chamados em uma ordem de depêndencia o seus namespaces.

Existem também variantes assíncronas, nesse caso você precisa fazer algum trabalho assíncrono que deveria completar antes de processar com o processo de reload.

.exemplo de async hooks
```clojure
(ns my.app)

(defn ^:dev/before-load-async stop [done]
  (js/console.log "stop")
  (js/setTimeout
    (fn []
      (js/console.log "stop complete")
      (done)))

(defn ^:dev/after-load-async start [done]
  (js/console.log "start")
  (js/setTimeout
    (fn []
      (js/console.log "start complete")
      (done)))
```

IMPORTANTE: A função vai receber uma função callback que deve ser chamada quando esse trabalho for completado. Se a função callback não for chamada o processo não será processado.

É possível tagear os namespaces com metadados então eles não irão nunca ser carregados mesmo sendo compilados. 

.Um non-reloadable ns
```
(ns ^:dev/once my.thing)

(js/console.warn "will only execute once")
```

Namespaces podem ser tageados para sempre serem recarregados.
Namespaces can also be tagged to always reload.

.Um always-reloadable ns
```
(ns ^:dev/always my.thing)

(js/console.warn "will execute on every code change")
```


==== Configuração

Além do metada é possível configurar os hooks do clico de vida através do `shadow-cljs.edn`.

[Horizontal]
`:before-load`:: Um símbolo (com namespace) de uma função para rodar antes de atualizar 
os arquivos que precisam ser recompilados. Essa função *must* é síncrona em natureza.
`:before-load-async`:: Um símbolo (com namespace) de uma função `(fn[done])` para rodar depois que o hot reload estiver completo. Essa função consegue fazer processamento assíncrono, mas o *must* chama `(done)` para indicar isso está completo.
`:autoload`:: Um boolean controlando se o código deveria ser hot loaded. Implicitamente `true` se qualquer uma das duas callbacks é setada. Sempre habilitado para o alvo `:browser` por padrão, configure para `false` para desabilitar.
`:ignore-warnings`:: Um boolean controlando se o código com alertas deveria ser recarregado. Padrão é `false`.

.Um exemplo do ciclo de vida dos hooks.
```
{...
 :builds
 {:app {...
        :devtools {:before-load  my.app/stop
                   :after-load   my.app/start
                   ...}}}}
```

DICA: Se nem `:after-load` nem `:before-load` estão configurados, o compilador vai apenas se preocupar para recarregar o código no alvo `:browser`. Se você ainda quer recarregar mas não precisa de algum dos callback, você pode configurar `:autoload true`, ao invés.

== Build Hooks [[build-hooks]]

Algumas vezes desejamos executar código customizado em um estágio especifico na pipeline de compilação. `:build-hooks` permite declarar quais funções devem ser chamados e eles tem controle total ao estado de build nesse tempo. Isso é bastante poderoso e abre muitas possibilidades de opções de ferramentas.

Eles são configurados por build dentro da chave `:build-hooks`

.Exemplo :build-hooks
```clojure
{...
 :builds
 {:app {:target ...
        :build-hooks
        [(my.util/hook 1 2 3)]
        ...}}}}
```

.Exemplo de código hook
```clojure
(ns my.util)

(defn hook
  {:shadow.build/stage :flush}
  [build-state & args]
  (prn [:hello-world args])
  build-state)
```

Esse exemplo chamaria `(my.util/hook build-state 1 2 3)` antes da build completar o `:flush` <<compilation-stages, stage>> (ex.: escreva no disco). O exemplo deveria exibir `[:hello-world (1 2 3)]` mas por favor, faça algo mais últil nos hooks de verdade.

O hook é apenas uma função *Clojure* normal com alguns metadados adicionais. O metadado `{:shadow.build/stage :flush}` informa ao compilador para chamar esse hook para `:flush` apenas. Você deve ao invés configurar `{"shadow.build/stages #{:configure :flush}}` se o hook deve ser chamado depois de múltiplos estágios. Pelo menos um estagio configurado é obrigatório desde o hook de outra forma nunca faz nada.

Toda build de hooks será chamada depois do `:target` concluído. Ele vai recever o `build-state` (um mapa clojure como todos os dados de build atuais) como primeiro argumento e *must* retornar esse `build-state` modificado ou não modificado. Quando usando múltiplos estágios você pode adicionar dados para o `build-state` que outras etapas podem acessar. Isso é fortemenete aconselhavel usar chaves namespaced apenas para ter certeza de não quebrar a build acidentalmente.

O `build-state` tem algumas imporantes entidades das quais deve ser úteis para seus hooks:

- `:shadow.build/build-id` - o id do build atual (ex. `:app`)
- `:shadow.build/mode` - `:dev` ou `:release`
- `:shadow.build/stage` - a etapa atual
- `:shadow.build/config` - a build de configuração. É possível ao invés de salvar o dado de configuração para o hook em um build config diretamente ou passar ele como argumento para o hook em si

IMPORTANTE: Rodando `watch` todos os hooks serão chamados repetidamente para cada build. Evite fazer muito trabalho porque eles podem consideravelmente impactar a performance da build

=== Estapas de compilação [[compile-stages]]

As possíveis estapas de `:build-hooks` são:

- `:configure` - inicial `:target` configuração especifica
- `:compile-prepare` - chamado antes que qualquer compilação seja feita
- `:compile-finish` - chamado depois que toda compilação é feita
- `:optimize-prepare` - chamado antes de rodar a fase de otimização do Closure Compiler (`:release` only)
- `:optimize-finish` - chamado depois que o Closure é feito (`:release` only)
- `:flush` - chamado depois que tudo foi embutido no disco

Enquanto `watch` o `:configure` é chamado apenas uma vez. Qualquer dos outros deve ser chamado 
novamente (em rodem) para cada re-compilação. O `build-state` será re-usado até o build config mudar aquele pedaço e isso será jogado fora e um novo será criado.

== Compiler Cache

`shadow-cljs` will cache all compilation results by default. The cache is invalidated whenever anything relevant to the individual source files changes (eg. changed compiler setting, changed dependencies, etc.). This greatly improves the developer experience since incremental compilation will be **much** faster than starting from scratch.

Invalidating the cache however can not always be done reliably if you are using a lot of macros with side-effects (reading files, storing things outside the compiler state, etc.). In those cases you might need to disable caching entirely.

Namespaces that are known to include side-effecting macros can be blocked from caching. They won't be cached themselves and namespaces requiring them will not be cached as well. The https://github.com/cerner/clara-rules[clara-rules] library has side-effecting macros and is blocked by default. You can specify which namespaces to block globally via the `:cache-blockers` configuration. It expects a set of namespace symbols.

.clara.rules cache blocking example (this is done by default)
```
{...
 :cache-blockers #{clara.rules}
 :builds {...}}
```

In addition you can control how much caching is done more broadly via the `:build-options` `:cache-level` entry. The supported options are:

[horizontal]
`:all`:: The default, all CLJS files are cached
`:jars`:: Only caches files from libraries, ie. source files in `.jar` files
`:off`:: Does not cache any CLJS compilation results (by far the slowest option)

.Compiling without Cache
```
{...
 :builds
 {:app
  {:target :browser
   ...
   :build-options
   {:cache-level :off}}}}
```

The cache files are stored in a dedicated directory for each build so the cache is never shared between builds. A build with the id `:app` will have the `:dev` cache in the directory:

.Cache location for `cljs/core.cljs`
```
target/shadow-cljs/builds/app/dev/ana/cljs/core.cljs.cache.transit.json
```

The `:cache-root` setting defaults to `target/shadow-cljs` and controls where ALL cache files will be written. It can only be configured globally, not per build.

```
{:source-paths [...]
 :dependencies [...]
 :cache-root ".shadow-cljs"
 :builds ...}

;; cache then goes to
;; .shadow-cljs/builds/app/dev/ana/cljs/core.cljs.cache.transit.json
```

The `:cache-root` is always resolved relative to the project directory. You can also specify absolute paths (eg. `/tmp/shadow-cljs`).

== Closure Defines [[closure-defines]]

The Closure Library & Compiler allow you to define variables that are essentially compile time constants. You can use these to configure certain features of your build. Since the Closure compiler treats these as constants when running `:advanced` optimizations they are fully supported in the Dead-Code-Elimination passes and can be used to remove certain parts of the code that should not be included in `release` builds.

You can define them in your code

```clojure
(ns your.app)

(goog-define VERBOSE false)

(when VERBOSE
  (println "Hello World"))
```

This defines the `your.app/VERBOSE` variable as `false` by default. This will cause the `println` to be removed in `:advanced` compilation. You can toggle this to `true` via the `:closure-defines` options which will enable the `println`. This can either be done for development only or always.

```clojure
{...
 :builds
 {:app
  {:target :browser
   ...
   :modules {:app {:entries [your.app]}}
   ;; to enable in development only
   :dev {:closure-defines {your.app/VERBOSE true}}
   ;; to enable always
   :closure-defines {your.app/VERBOSE true}
   ;; you may also enable it for release as well
   :release {:closure-defines {your.app/VERBOSE true}}
   }}
```

TIP: It is generally safer to use the "disabled" variant as the default since it makes things less likely to be included in a `release` build when they shouldn't be. Forgetting to set a `:closure-defines` variable should almost always result in less code being used not more.

*Closure Defines from the Closure Library*

- `goog.DEBUG`: The Closure Library uses this for many development features. `shadow-cljs` automatically sets this to `false` for `release` builds.
- `goog.LOCALE` can be used to configure certain localization features like `goog.i18n.DateTimeFormat`. It accepts a standard locale string and defaults to `en`. Pretty much all locales are supported, see https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbols.js[here] and https://github.com/google/closure-library/blob/master/closure/goog/i18n/datetimesymbolsext.js[here].

== Compiler Options [[compiler-options]]

The CLJS compiler supports several options to influence how some code is generated. For the most part `shadow-cljs` will pick some good defaults for each `:target` but you might occasionally want to change some of them.

These are all grouped under the `:compiler-options` key in your build config.

```clojure
{:dependencies [...]
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:fn-invoke-direct true}}}}
```

Most of the standard ClojureScript https://clojurescript.org/reference/compiler-options[Compiler Options] are either enabled by default or do not apply. So very few of them actually have an effect. A lot of them are also specific to certain `:target` types and do not apply universally (e.g. `:compiler-options {:output-wrapper true}` is only relevant for `:target :browser`).

Currently supported options include

- `:optimizations` supports `:advanced`, `:simple` or `:whitespace`, defaults to `:advanced`. `:none` is the default for development and cannot be set manually. `release` with `:none` won't work.
- `:infer-externs` `:all`, `:auto`, `true` or `false`, defaults to `true`
- `:static-fns` (Boolean) defaults to `true`
- `:fn-invoke-direct` (Boolean) defaults to `false`
- `:elide-asserts` (Boolean) default to `false` in development and `true` in `release` builds
- `:pretty-print` and `:pseudo-names` default to `false`. You can use `shadow-cljs release app --debug` to enable both temporarily without touching your config. This is very useful when running into problem with `release` builds
- `:source-map` (Boolean) defaults to `true` during development, `false` for `release`.
- `:source-map-include-sources-content` (Boolean) defaults to `true` and decides whether source maps should contains their sources in the `.map` files directly.
- `:source-map-detail-level` `:all` or `:symbols` (`:symbols` reduces overall size a bit but also a bit less accurate)
- `:externs` vector of paths, defaults to `[]`
- `:checked-arrays` (Boolean), defaults to `false`
- `:anon-fn-naming-policy`
- `:rename-prefix` and `:rename-prefix-namespace`
- `:warnings` as a map of `{warning-type true|false}`, eg. `:warnings {:undeclared-var false}` to turn off specific warnings.

*Unsupported or non-applicable Options*

Options that don't have any effect at all include

- `:verbose` is controlled by running `shadow-cljs compile app --verbose` not in the build config.
- `:foreign-libs` and `:libs`
- `:stable-names` always enabled, cannot be disabled
- `:install-deps`
- `:source-map-path`, `:source-asset-path` and `:source-map-timestamp`
- `:cache-analysis` always enabled, cannot be disabled.
- `:recompile-dependents`
- `:preamble`
- `:hashbang` (the `:node-script` target supports this, others don't)
- `:compiler-stats` use `--verbose` to get detailed information instead
- `:optimize-constants` always done for `release` builds, cannot be disabled
- `:parallel-build` always enabled
- `:aot-cache`
- `:package-json-resolution` see <<js-resolve, :js-options :resolve>> instead
- `:watch-fn`
- `:process-shim`

=== Warnings as Errors [[warnigs-as-errors]]

It is sometimes desireable to fail a build with warnings rather than continuing with the build (eg. in CI envs). You can use the `:warnings-as-errors` compiler options to customize how that is handled.

.Treat all warnings as errors
```
{...
 :builds
 {:app
  {...
   :compiler-options {:warnings-as-errors true}}}}
```

.Only throw certain warnings
```
{...
 :builds
 {:app
  {...
   :compiler-options {:warnings-as-errors #{:undeclared-var}}}}
```

A set of possible warning-type keywords can be found https://github.com/clojure/clojurescript/blob/5ad96a8b3ae2e3616a19715ba9ba2471a36933a2/src/main/clojure/cljs/analyzer.cljc#L124-L163[here].

.Only throw for certain namespaces
```
{...
 :builds
 {:app
  {...
   :compiler-options {:warnings-as-errors {:ignore #{some.ns some.library.*}
                                           :warnings-types #{:undeclared-var}}}
```

`:ignore` takes a set of symbols refering to namespaces. Either direct matches or `.*` wildcards are allowed. `:warning-types` has the same functionality as above, not specifying it means all warnings will throw except the ignored namespaces.


== Output Language Options

By default the generated JS output will be compatible with ES5 and all "newer" features will be transpiled to compatible code using polyfills. This is currently the safest default and supports most browsers in active use (including IE10+).

You can select other output options if you only care about more modern environments and want to keep the original code without replacements (eg. `node`, Chrome Extensions, ...)

IMPORTANT: Note that this mostly affects imported JS code from <<npm, npm>> or `.js` files from the <<classpath-js, classpath>>. CLJS will currently only generate ES5 output and is not affected by setting higher options.

You can configure this via the `:output-feature-set` in `:compiler-options`. The older `:language-out` option should not be used as `:output-feature-set` replaced it.

Supported options are:

- `:es3`
- `:es5`
- `:es6` - `class`, `const`, `let`, ...
- `:es7` - exponent `**` operator
- `:es8` - `async/await`, `generators`, object literals with spread, ...
- `:es-next` - all the features the Closure Compiler currently supports

.Example
```
{...
 :builds
 {:script
  {:target :node-script
   :main foo.bar/main
   ...
   :compiler-options {:output-feature-set :es7}}}}
```

Documentation on these options is a bit sparse and is mostly documented in the code https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/parser/FeatureSet.java[here].


== Conditional Reading

CAUTION: This feature only works in `shadow-cljs`. It was officially https://dev.clojure.org/jira/browse/CLJS-2396[rejected] by the ClojureScript project. It will still compile fine in CLJS but only the official branches work (e.g. `:cljs`). It might still be https://groups.google.com/d/msg/clojure-dev/8YJJM8lJuQs/hR5_vUZPCQAJ[supported] one day but as of now it is not.

`shadow-cljs` lets you configure additional reader features in `.cljc` files. By default you can only use reader conditionals to generate separate code for `:clj`, `:cljs` or `:cljr`. In many CLJS builds however it is also desirable to select which code is generated based on your `:target`.

Example: Some `npm` packages only work when targeting the `:browser`, but you may have a `ns` that you also want to use in a `:node-script` build. This might happen frequently when trying to use Server-Side Rendering (SSR) with your React App. `codemirror` is one such package.

```clojure
(ns my.awesome.component
  (:require
    ["react" :as react]
    ["codemirror" :as CodeMirror]))

;; suppose you create a CodeMirror instance on some React :ref
(defn init-cm [dom-node]
  (let [cm (CodeMirror/fromTextArea dom-node #js {...})]
    ...))

...
```

This namespace will compile fine for both builds (`:node-script` and `:browser`) but when trying to run the `:node-script` it will fail since the `codemirror` package tries to access the DOM. Since `react-dom/server` does not use refs the `init-cm` function will never be called anyways.

While you can use <<closure-defines, :closure-defines>> to conditionally compile away the `init-cm` fn you can not use it to get rid of the extra `:require`. Reader conditionals let you do this easily.

```clojure
(ns my.awesome.component
 (:require
   ["react" :as react]
   ;; NOTE: The order here matters. Only the first applicable
   ;; branch is used. If :cljs is used first it will still be
   ;; taken by the :server build
   #?@(:node [[]]
       :cljs [["codemirror" :as CodeMirror]])))

#?(:node ;; node platform override
   (defn init-cm [dom-node]
    :no-op)
   :cljs ;; default impl
   (defn init-cm [dom-node]
     ... actual impl ...))

...
```

.`:reader-features` config examples
```clojure
{...
 :builds
 ;; app build configured normally, no adjustments required
 {:app
  {:target :browser
   ...}
  ;; for the server we add the :node reader feature
  ;; it will then be used instead of the default :cljs
  :server
  {:target :node-script
   :compiler-options
   {:reader-features #{:node}}}}}
```

The `:server` build will then no longer have the `codemirror` require and the `init-cm` function is removed. Becoming only

```clojure
(ns my.awesome.component
  (:require
    ["react" :as react]))

;; this will likely be removed as dead code if
;; its never actually called anywhere

(defn init-cm [dom-node] :no-op)
...
```

IMPORTANT: This feature is only available in `.cljc` files and will fail in `.cljs` files.

== Overriding from the CLI [[config-merge]]

It is sometimes desirable to make small adjustments to the build configuration from the command line with values that can't be added statically to the `shadow-cljs.edn` config or may change depending on the environment you are in.

You can pass additional config data via the `--config-merge {:some "data"}` command line option which will be merged into the build config. Data added from the CLI will override data from the `shadow-cljs.edn` file.

.Example `shadow-cljs.edn` config
```
{...
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   ...}}}
```

.Overriding the `:output-dir` from the CLI
```bash
$ shadow-cljs release app --config-merge '{:output-dir "somewhere/else"}'
```

.Overriding the `:closure-defines` from the CLI
```bash
$ shadow-cljs release app --config-merge '{:closure-defines {your.app/DEBUG true}}'
```

`--config-merge` expects one EDN map and can be used multiple times, they will be merged left to right. The data added is also visible to build-hooks.

IMPORTANT: If you specify multiple build ids the data will be merged into all specified builds. `shadow-cljs release frontend backend --config-merge '{:hello "world"}'` will be applied to both.

== Using Environment Variables [[shadow-env]]

It is possible to use environment variables to set configuration values in `shadow-cljs.edn` but you should consider using `--config-merge` instead. If you really must use an environment variable you can do so via the `#shadow/env "FOO"` reader tag.

.Example `shadow-cljs.edn` config
```
{...
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :closure-defines {your.app/URL #shadow/env "APP_URL"}
   ...}}}
```

IMPORTANT: The environment variables used when the `shadow-cljs` process was started are used. If a server process is used its environment variables will be used over those potentially set by other commands. This is mostly relevant during development but may be confusing. `--config-merge` does not have this limitation.

== Build and Target defaults [[build-target-defaults]]

It is possible to use set defaults that will be used for all builds, or for all targets of a certain type.

Configuration merge order is as follows `:build-defaults` -> `:target-defaults` -> actual build config -> extra config overrides.

.Example `shadow-cljs.edn` config
```
{...
 :build-defaults
 {:closure-defines 
   {your.app/VERBOSE true}}
   
 :target-defaults
 {:browser
   {:js-options
     {:resolve {"react" {:target :global
                         :global "React"}}}}}
 
 :builds
 {:app
  {:target :browser
   ...}}}
```

In this example the `:app` target will inherit both `:build-defaults` and the `:target-defaults` for `:browser`.

IMPORTANT: Configs later in the merge order can override, but not remove previous configuration items. Once a default is set, the only way to remove it is by overriding it.
