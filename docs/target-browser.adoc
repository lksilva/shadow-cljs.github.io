O target `:browser` produz a saída esperada pra rodar no ambiente do navegeador. Durante o desenvolvimento ele suporta live reloading do código, REPL, CSS reloading. A saída `release` será minificada pelo Closure Compiler com as otimizações `:advanced`.

A configuração básica do navegar parece algo como esse:

```
{:dependencies [...]
 :source-paths [...]

 :builds
 {:app {:target :browser
        :output-dir "public/assets/app/js"
        :asset-path "/assets/app/js"
        :modules {:main {:entries [my.app]}}}]}
```

== Output Settings

O target do navegador produz uma saída com um monte de arquivos, e um diretório é preciso para armazenar todos eles. Você vai precisar
servir esses arquivos com algum tipo de servidor, e para carregar o código Javascript você precisa conhecer o caminho desses arquivos.
As opções que você precisa especificar são:

[Horizontal]
`:output-dir`:: The directory to use for all compiler output.
`:asset-path`:: The relative path from *web server's root* to the resources in `:output-dir`.

O ponto de entrada do arquivo JavaScript e todos os arquivos JS relacionados vão aparecer no `:output-dir`.

ATENÇÃO: Cada build requer seu próprio :output-dir, você não deve atribuir multiplos builds para o mesmo diretório.
Esse diretório deveria ser exclusivo do dono do build. Não deve haver nenhum outro arquivo lá.
Enquanto `shadow-cljs` não for deleter nada é seguro deixar pra lá. Compilação
cria muito mais arquivos que apenas o principal ponto de entrada do arquivo JS durante o desenvolvimento:
source map, fontes originais, e fontes gerados.

O `:asset-path` é um prefixo que é adicionado ao paths do modulo quando carregando código dentro do 
javascript gerado. Isso permito você delimitar a saída do seu modulo javascript para um sub-diretório em particular 
da raíz do seu servidor web. O carregamento dinâmico durante o desenvolvimento (hot code reload) e produção 
(code splitting) precisa disso alocar corretamente os arquivos.

Localizando seus arquivos gerados em diretório e o asset path como esse faz com que outros assets (images, css, etc.)
possam facilmente co-existir no mesmo servidor sem colisões acidentais.

Por exemplo: se seu servidor web servir a pasta `public/x` quando requisitade para o URI `/x`,
e seu `output-dir` para um module é `public/assets/app/js` então seu asset-path deveria ser `/assets/app/js`.
Não é obrigatório usar o caminho absolut para o pasth, but é fortemente recomendado.

== Modulos

Modulos configuram como os fontes compilados são empacotados juntos e como o `.js` final é gerado. Cada módulo declara uma lista de Namespace de entrada e a partir dessio e dependência de graph é construida. Quando usando multiplos modulos o código é divido então a quantidade máxima do código é movida para as bordas externas do graph. O objetivo é minimizar a quantidade de código que o navegador tem que carregar inicialmente e carregar o resto sobre demanda.

DICA: Não se preocupe muito sobre :modules no começo. Comece com apenas um e divida eles depois.

A sessão de configuração do `:modules` é sempre um mapa chaveado pelo ID do modulo. O ID do module também é usado
para gerar o nome do arquivo Javascript. Module `:main` vai gerar o `main.js` no `:output-dir`.

As opções disponiveis em um modulo são:

[horizontal]
`:entries`:: O namespace que serve com a raíz dos nodes do grafo de dependências para o código de saída desse modulo.
`:init-fn`:: O symbol qualificado para apontar a uma função que deveria ser chamada quando o módulo for carregado inicialmente.
`:depends-on`:: Os nomes dos módulos que devem ser carregado em ordem para ter tudo que é preciso para funcionar adequadamente.
`:prepend`:: String que ira prefixar a saída js. Útil para comentários, copyright, etc.
`:append`:: String que vai acrescentar a saída js. Útil para comentários, copyright, etc.
`:prepend-js`:: Uma string para prefixar o módulo de saída contendo um javascript válido que vai rodar através do Closure optimizer.
`:append-js`:: Uma string pra acrescentar o módulo de saída contendo javascript válido que vai rodar através do Closure optimizer.

O seguinte exemplo mostra o configuração minima do módulo:

.Examplo :browser config
```
{...
 :builds
 {:app {:target :browser
        :output-dir "public/js"
        ...
        :modules {:main {:entries [my.app]}}}}}
```

.Examplo :browser config com :init-fn
```
{...
 :builds
 {:app {:target :browser
        :output-dir "public/js"
        ...
        :modules {:main {:init-fn my.app/init}}}}}
```

`shadow-cljs` seguira a dependência de grafo a partir do conjunto raíz do ponto de entrada em `:entries``
para encontrar tudo que é preciso para na verdade compilar e incluir na saída. Namespaces que não são requeridas não serão incluidas.

A configuração acima vai criar um arquivo `public/js/main.js`. Durante o desenvolvimento haverá um diretório adicional `public/js/cljs-runtime` com vários arquivos. Esse diretório não é requerido para builds `release`.

== Code Splitting [[CodeSplitting]]

Declarando mais que um Module requer um pouquinho de configuração estatica adicional então o Compiler pode descobrir como os Modulos são relacionado uns com os outros e como vão ser carregados mais tarde.

Além de `:entries` você vai precisar declar quais modulos dependes de quais (via `:depends-on`). Como você estrutura depende inteiramente das suas necessidades e não existe uma solução bala de prata nessa situação.

Digamos que você tenha um website tradicional com pagínas diferentes.

- `www.acme.com` - serve a página inicial
- `www.acme.com/login` - serve o formulário de login
- `www.acme.com/protected` - sessão protegida que só é disponível quando o usuário ta logado

Uma boa configuração para isso seria ter um módulo common que é compartilhado entre todas as páginas. Então uma para cada página.

.Exemplo de config com múltiplos módulos `:modules`
```clojure
{...
 :output-dir "public/js"
 :modules
 {:shared
  {:entries [my.app.common]}
  :home
  {:entries [my.app.home]
   :depends-on #{:shared}}
  :login
  {:entries [my.app.login]
   :depends-on #{:shared}}
  :protected
  {:entries [my.app.protected]
   :depends-on #{:shared}}
```

DICA: É possível deixar o `:entries` do modulo `:shared` vázio para permitir que o compilador descubra quais namespaces são compartilhados entre os outros módulos.

.Estrutura de arquivos geradas
```text
.
└── public
    └── js
        ├── shared.js
        ├── home.js
        ├── login.js
        └── protected.js
```

No seu HTML para a página inicial você então sempre inclui o `shared.js` em cada página e outros condicionalmente dependen de qual página o usuário está online.

.HTML para a página de `/login`
```html
<script src="/js/shared.js"></script>
<script src="/js/login.js"></script>
```

IMPORTANTE: Os arquivos `.js` devem ser incluidos na ordem correta. O <<BrowserManifest, `manifest.edn`>> pode ajudar com isso.

=== Carregando código dinamicamente

Atualmente os Sigle-Page-Apps (SPA) estão se tornando mais populares e eles trabalham de maneira semelhante ao invés de deixar o servidor decidir qual JS incluir ao Client ele faz isso por si só.

==== Usando shadow-cljs's built-in Loader Support

O compiler suporta gerar o dado requerido usando o `shadow.loader` namespace. Ele expõe uma simples interface que permite carregar modules sob demanda em tempo de compilação.

Você apenas precisa adicionar o `:module-loader true` ao seu build config. O loader vai sempre ser injetado em um módulo padrão (aquele do qual todo mundo depende).

No runtime você deve usar o namespace `shadow.loader` para carregar os modulos. Você deve também carregar o módulo avidamente apenas usando uma tag `<script>` na sua página.

```
{...
 :builds
   {:app
     {:target :browser
      ...
      :module-loader true
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}
```

Se você teve o seguinte entry point:

```
(ns my.app
  (:require [shadow.loader :as loader]))

(defn fn-to-call-on-load []
  (js/console.log "extra loaded"))

(defn fn-to-call-on-error []
  (js/console.log "extra load failed"))
```

Então a expressão a seguir pode ser usada para carregar o código:

.Carregando um módulo
```
;; load returns a goog.async.Deferred, and can be used like a promise
(-> (loader/load "extra")
    (.then fn-to-call-on-load fn-to-call-on-error))
```

.Carregando muitos módulos
```
;; must be a JS array, also returns goog.async.Deferred
(loader/load-many #js ["foo" "bar"])
```

.Incluindo uma callback
```
(loader/with-module "extra" fn-to-call-on-load)
```

Você pode checar se um módulo é carregado usando `(loaded? "module-name")`.

===== Custos do Loader

Usar o loader é bastante leve. Ele tem poucas dependências das quais você não deve ser muito claro usando. Em prática usar `:module-loader true` adicionar 8KB gzip'd para o modulo padrão. Isso vai variar dependendo quanto do `goog.net` e `goog.events` você já está usando, e em qual nível de otimização você usa para o seus builds de release.

==== Usando o padrão da ClojureScript API

O código gerado é capaz de usar a API padrão ClojureScript `cljs.loader`. Veja a
https://clojurescript.org/news/2017-07-10-code-splitting[documentação] no website ClojureScrip
para mais informações.

A vantagem de usar a API padrão é que seu código vai funcionar bem com outras APIs. Isso
deve ser de uma importância particular para criadores de bibliotecas. A desvantagem é que o módulo dinamico
carregando a API em uma distribuição padrão é um pouco menos fácil de usar do que o 
suporte no `shadow-cljs`.

== Output Wrapper [[output-wrapper]]

*Apenas builds release*: O código gerado pela compilação `:advanced` do Closure Compiler vai criar um monte de variaveis globais das quais podem criar conflitos com outro JS rodando na página. Para isolar as variaveis criadas o código pode ser encapsulado em uma função anonima para as variaveis aplicadas apenas nesse escopo.

build de `release` para `:browser` com apenas um `:modules` são encapsulados em `(function(){<the-code>}).call(this);` por padrão. Então variaveis globais não são criadas.

Quando usando multiplos `:modules` (a.k.a <<CodeSplitting, code splitting>>) isso não é habilitado por padrão desde que cada modulo deve ser capaz de acessar as variaveis criadas pelo modulo que ela depende. O Closure Compiler suporta uma opção adicional para o habilitar o uso de uma saída encapsulada em combinação com multiplos `:modules` nomeado como `:rename-prefix-namespace`. Este será o caso para todos os escopos de variaveis "global" usada pelo build dentro de uma variavel global. Por padrão esse é o conjunto para `:rename-prefix-namespace "$APP"` quando `:output-wrapper` é configurado para `true`.

```clojure
{...
 :builds
 {:target :browser
  ...
  :compiler-options
  {:output-wrapper true
   :rename-prefix-namespace "MY_APP"}}}
```

Isso vai criar uma variável global `MY_APP`. Desde que cada variavel "global" vai ser prefixada agora para `MY_APP`. (ex. `MY_APP.a` ao invés de apenas `a`) o tamanho do código pode aumentar substâncialmente. É importante manter isso pequeno. A compressão do navegador (ex `gzip`) ajuda a reduzir a sobrecarga de código extra mas dependendo da quantidade de variaveis globais em seu build isso pode ainda produzir um notável aumento.

IMPORTANTE: Perceba que a variavel criada não é diretamente últil na verdade. Ela vai conter um monte de propriedades minificadas. Todas as variaveis exportadas (ex. `^:export`) ainda vão ser exportadas dentro de um escopo global e não são diretamente afetadas por essa configuração. A configuração vai apenas servir para limitar a quantidade de variaveis globais criadas, nada mais que isso. Não use isso diretamente.

== Web Workers

A configuração `:modules` deve também ser usada para gerar arquivos desejados para serem usados como um Web Workers.
Você deve declarar qualquer modulo como um Web Worker configurando `:web-worker true`. O
arquivo gerado vai conter alguns códigos adicionais dos quais carrega as dependências automaticamente.
O `:modules` trabalha para garantir que o código usado apenas pelo worker vai também também está
apenas no arquivo final para o worker. Cada worker deveria ter um namespace CLJS dedicado.

.Um exemplo de geração de um script web worker
```
{...
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :asset-path "/js"
   ...
   :modules
   {:shared
    {:entries []}
    :main
    {:init-fn my.app/init
     :depends-on #{:shared}}
    :worker
    {:init-fn my.app.worker/init
     :depends-on #{:shared}
     :web-worker true}}
   :devtools {:browser-inject :main}
   }}}
```

A configuração vai gerar um `worker.js` da qual você pode usar para iniciar o Web Worker.
Isso vai ter todo o código a partir do modulo `:shared` disponível (mas não `:main`). O código no
namespace `my.app.worker` será apenas executado no worker. A geração do Worker acontece em ambos
os modos desenvolvimento e release.

Perceba que `:entries []` no módulo `:shared` vai fazer isso coletar todos os códigos compartilhados entre o `:main` e os modulos `:worker`.

O `:devtools {:browser-inject :main}` é atualmente requerido para falar ao compiler onde o navegador devtools/hud deveria ser adicionado. o Padrão para adicionar eles para o modulo "base" do qual seria `:shared` nesse caso. Desde que ele contém código não compátivel com o ambiente Worker nós precisamos mover ele. 

.Amostra do worker
```
(ns my.app.worker)

(defn init []
  (js/self.addEventListener "message"
    (fn [^js e]
      (js/postMessage (.. e -data)))))
```

.Sample using the worker
```
(ns my.app)

(defn init []
  (let [worker (js/Worker. "/js/worker.js")]
    (.. worker (addEventListener "message" (fn [e] (js/console.log e))))
    (.. worker (postMessage "hello world"))))
```

IMPORTANTE: Desde nós agora temos um modulo `:shared` você deve ter certeza de carregar ele adequadamente em seu HTML. Se você apenas carrega o `main.js` você vai gerar um erro.

.HTML Carregando shared.js e main.js
```
<script src="/js/shared.js"></script>
<script src="/js/main.js"></script>
```

== Cachenado Saída 

Nas configuração da web é desejavel cachear os arquivos `.js` por um longo tempo com a finalidade de evitar requests desnecessárias. É uma prática comum
gerar arquivos `.js` únicos para cada versão lançada. Isso muda a URL usada para
acessar ele e assim é seguro cachear para sempre.

=== Versões de lançamento [[release-version]]

Criando nomes de arquivos únicos para cada lançamento pode ser feito através da configuração `:release-version`. Geralmente você vai passar isso a partir da linha de comando via <<config-merge, --config-merge>>.

```
shadow-cljs release app --config-merge '{:release-version "v1"}'
```

.Exemplo do config :modules
```
{...
 :builds
   {:app
     {:target :browser
      ...
      :output-dir "public/js"
      :asset-path "/js"
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}
```

Isso criaria o `main.v1.js` e `extra.v1.js` em arquivos no `public/js` ao invés do `main.js` e `extra.js`.

Você pode criar versões manuais ou algo automatizado como o `git`no tempo de build.

=== Nomes de arquivos com Fingerprint-Hash [[NameHashing]]

É possível adicionar `:module-hash-names true` para seu build config manualmente, crie uma assinatura MD5
para cada modulo gerado. Isso significa que o modulo `:main` vai gerar um `main.<md5hash>.js` ao invés do
padrão `main.js`.

`:module-hash-names true` vai incluir o hash md5 32-length completo , se você preferir uma versão mais curta você pode especificar um
número entre 1-32 (ex. `:module-hash-names 8`). Esteja consciente que encurtar o hash deve aumentar as chances de conflito. 
Eu recomendo o hash completo.

.Exemplo de config :module-hash-names
```
{...
 :builds
   {:app
     {:target :browser
      ...
      :output-dir "public/js"
      :asset-path "/js"
      :module-hash-names true
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}
```

Ao invés de gerar o `main.js` isso vai gerar um `main.<hash>.js` no `:output-dir`. 

Desde que o nome do arquivo pode mudar com cada release fica um pouco mais complicado incluir eles
no seu HTM. O <<BrowserManifest, Output Manifest>> pode ajudar com isso.

== Manifesto de Saída [[BrowserManifest]]

`shadow-cljs` gera um arquivo `manifest.edn` no `:output-dir` configurado.
Esse arquivo contém uma descrição do modulo config juntamente com um propriedade extra `:output-name` da qual
mapeia o modulo original para o nome de arquivo atual (importante quando usando a funcionalidade `:module-hash-names`).

.Exemplo de saída do manifest.edn quando usando nomes de arquivos hasheados.
```
[{:module-id :common,
  :name :common,
  :output-name "common.15D142F7841E2838B46283EA558634EE.js",
  :entries [...],
  :depends-on #{},
  :sources [...]}
 {:module-id :page-a,
  :name :page-a,
  :output-name "page-a.D8844E305644135CBD5CBCF7E359168A.js",
  :entries [...],
  :depends-on #{:common},
  :sources [...]}
 ...]
```

O manifest contém todos os `:modules` ordernados em ordem de dependência. É possível usar isso para mapear o `:module-id` de volta
para o nome de arquivo gerado.

Builds de desenvolvimento também produzem esse arquivo e você deve verificar modificações conhecidas
quando a nova build estiver completa. `:module-hash-names` não é aplicada durante o desenvolvimento 
então você vai pegar os filenames.

Você pode configurar o nome dos arquivos manifest gerados através do `:build-options :manifest-name`. É o padrão para
`manifest.edn`. Se você configura um nome de arquivo com `.json` terminando a saída será um JSON ao invés de um EDN. O arquivo vai
ser relative ao configurado no `:output-dir`.

.Exemplo de config manifest.json
```
{...
 :builds
   {:app
     {:target :browser
      ...
      :build-options {:manifest-name "manifest.json"}
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}
```

== Development Support

The `:devtools` section of the configuration for `:browser` supports a few additional
options for configuring an optional dev-time HTTP server for a build and CSS reloading.

=== Heads-Up Display (HUD) [[hud]]

The `:browser` target now uses a HUD to display a loading indicator when a build is started. It will also display warnings and errors if there are any.

You can disable it completely by setting `:hud false` in the `:devtools` section.

You may also toggle certain features by specifying which features you care about via setting `:hud #{:errors :warnings}`. This will show errors/warnings but no progress indicator. Available options are `:errors`, `:warnings`, `:progress`. Only options included will be enabled, all other will be disabled.

==== Opening Files [[open-file-command]]

Warnings include a link to source location which can be clicked to open the file in your editor. For this a little bit of config is required.

You can either configure this in your `shadow-cljs.edn` config for the project or globally in your home directory under `~/.shadow-cljs/config.edn`.

.`:open-file-command` configuration
```clojure
{:open-file-command
 ["idea" :pwd "--line" :line :file]}
```

The `:open-file-command` expects a vector representing a very simple DSL. Strings are kept as they are and keyword are replaced by their respective values. A nested vector can be used in case you need to combine multiple params, using `clojure.core/format` style pattern.

The above example would execute
```bash
$ idea /path/to/project-root --line 3 /path/to/project-root/srv/main/demo/foo.cljs
```

.`emacsclient` example
```
{:open-file-command
 ["emacsclient" "-n" ["+%s:%s" :line :column] :file]}
```

```bash
$ emacsclient -n +3:1 /path/to/project-root/srv/main/demo/foo.cljs
```

The available replacement variables are:

[Horizontal]
`:pwd`::
Process Working Directory (aka project root)

`:file`::
Absolute File Path

`:line`::
Line Number of Warning/Error

`:column`::
Column Number

`:wsl-file`::
Translated WSL file path. Useful when running `shadow-cljs` via WSL Bash. Translates a `/mnt/c/Users/someone/code/project/src/main/demo/foo.cljs` path into `C:\Users\...`

`:wsl-pwd`::
Translated `:pwd`



=== CSS Reloading

The Browser devtools can also reload CSS for you. This is enabled by default and in most cases requires no additional
configuration when you are using the built-in <<dev-http, development HTTP servers>>.

Any stylesheet included in a page will be reloaded if modified on the filesystem. Prefer using absolute paths but relative paths should work as well.

.Example HTML snippet
```html
<link rel="stylesheet" href="/css/main.css"/>
```

.Example Hiccup since we aren't savages
```
[:link {:rel "stylesheet" :href "/css/main.css"}]
```

.Using the built-in dev HTTP server
```
:dev-http {8000 "public"}
```

This will cause the browser to reload `/css/main.css` when `public/css/main.css` is changed.

`shadow-cljs` currently provides no support for directly compiling CSS but the usual tools will work and should
be run separately. Just make sure the output is generated into the correct places.

When you are not using the built-in HTTP Server you can specify `:watch-dir` instead which should be a path to the
document root used to serve your content.

.Example :watch-dir config
```clojure
{...
    {:builds
      {:app {...
             :devtools {:watch-dir "public"}}}}
```

When your HTTP Server is serving the files from a virtual directory and the filesystem paths don't exactly match the path used in the HTML you may adjust the path by setting `:watch-path` which will be used as a prefix.

.Example `public/css/main.css` being served under `/foo/css/main.css`
```clojure
{...
 {:builds
  {:app
   {...
    :devtools {:watch-dir "public"
               :watch-path "/foo"}}}}
```

=== Proxy Support [[proxy-support]]

By default the devtools client will attempt to connect to the `shadow-cljs` process via the configured <<http, HTTP server>> (usually `localhost`). If you are using a reverse proxy to serve your HTML that might not be possible. You can set `:devtools-url` to configure which URL to use.

```
{...
 :builds
 {:app {...
        :devtools {:before-load  my.app/stop
                   :after-load   my.app/start
                   :devtools-url "https://some.host/shadow-cljs"
                   ...}}}}
```

`shadow-cljs` will then use the `:devtools-url` as the base when making requests. It is not the final URL so you must ensure that all requests starting with the path you configured (eg. `/shadow-cljs/*`) are forwarded to the host `shadow-cljs` is running on.


.Incoming Request to Proxy
```text
https://some.host/shadow-cljs/ws/foo/bar?asdf
```
.must forward to
```
http://localhost:9630/foo/bar?asdf
```

The client will make WebSocket request as well as normal XHR requests to load files. Ensure that your proxy properly upgrades WebSockets.

IMPORTANT: The requests must be forwarded to the main <<http, HTTP server>>, not the one configured in the build itself.

