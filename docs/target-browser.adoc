O target `:browser` produz a saída esperada pra rodar no ambiente do navegeador. Durante o desenvolvimento ele suporta live reloading do código, REPL, CSS reloading. A saída `release` será minificada pelo Closure Compiler com as otimizações `:advanced`.

A configuração básica do navegar parece algo como esse:

```
{:dependencies [...]
 :source-paths [...]

 :builds
 {:app {:target :browser
        :output-dir "public/assets/app/js"
        :asset-path "/assets/app/js"
        :modules {:main {:entries [my.app]}}}]}
```

== Output Settings

O target do navegador produz uma saída com um monte de arquivos, e um diretório é preciso para armazenar todos eles. Você vai precisar
servir esses arquivos com algum tipo de servidor, e para carregar o código Javascript você precisa conhecer o caminho desses arquivos.
As opções que você precisa especificar são:

[Horizontal]
`:output-dir`:: The directory to use for all compiler output.
`:asset-path`:: The relative path from *web server's root* to the resources in `:output-dir`.

O ponto de entrada do arquivo JavaScript e todos os arquivos JS relacionados vão aparecer no `:output-dir`.

ATENÇÃO: Cada build requer seu próprio :output-dir, você não deve atribuir multiplos builds para o mesmo diretório.
Esse diretório deveria ser exclusivo do dono do build. Não deve haver nenhum outro arquivo lá.
Enquanto `shadow-cljs` não for deleter nada é seguro deixar pra lá. Compilação
cria muito mais arquivos que apenas o principal ponto de entrada do arquivo JS durante o desenvolvimento:
source map, fontes originais, e fontes gerados.

O `:asset-path` é um prefixo que é adicionado ao paths do modulo quando carregando código dentro do 
javascript gerado. Isso permito você delimitar a saída do seu modulo javascript para um sub-diretório em particular 
da raíz do seu servidor web. O carregamento dinâmico durante o desenvolvimento (hot code reload) e produção 
(code splitting) precisa disso alocar corretamente os arquivos.

Localizando seus arquivos gerados em diretório e o asset path como esse faz com que outros assets (images, css, etc.)
possam facilmente co-existir no mesmo servidor sem colisões acidentais.

Por exemplo: se seu servidor web servir a pasta `public/x` quando requisitade para o URI `/x`,
e seu `output-dir` para um module é `public/assets/app/js` então seu asset-path deveria ser `/assets/app/js`.
Não é obrigatório usar o caminho absolut para o pasth, but é fortemente recomendado.

== Modulos

Modulos configuram como os fontes compilados são empacotados juntos e como o `.js` final é gerado. Cada módulo declara uma lista de Namespace de entrada e a partir dessio e dependência de graph é construida. Quando usando multiplos modulos o código é divido então a quantidade máxima do código é movida para as bordas externas do graph. O objetivo é minimizar a quantidade de código que o navegador tem que carregar inicialmente e carregar o resto sobre demanda.

DICA: Não se preocupe muito sobre :modules no começo. Comece com apenas um e divida eles depois.

A sessão de configuração do `:modules` é sempre um mapa chaveado pelo ID do modulo. O ID do module também é usado
para gerar o nome do arquivo Javascript. Module `:main` vai gerar o `main.js` no `:output-dir`.

As opções disponiveis em um modulo são:

[horizontal]
`:entries`:: O namespace que serve com a raíz dos nodes do grafo de dependências para o código de saída desse modulo.
`:init-fn`:: O symbol qualificado para apontar a uma função que deveria ser chamada quando o módulo for carregado inicialmente.
`:depends-on`:: Os nomes dos módulos que devem ser carregado em ordem para ter tudo que é preciso para funcionar adequadamente.
`:prepend`:: String que ira prefixar a saída js. Útil para comentários, copyright, etc.
`:append`:: String que vai acrescentar a saída js. Útil para comentários, copyright, etc.
`:prepend-js`:: Uma string para prefixar o módulo de saída contendo um javascript válido que vai rodar através do Closure optimizer.
`:append-js`:: Uma string pra acrescentar o módulo de saída contendo javascript válido que vai rodar através do Closure optimizer.

O seguinte exemplo mostra o configuração minima do módulo:

.Examplo :browser config
```
{...
 :builds
 {:app {:target :browser
        :output-dir "public/js"
        ...
        :modules {:main {:entries [my.app]}}}}}
```

.Examplo :browser config com :init-fn
```
{...
 :builds
 {:app {:target :browser
        :output-dir "public/js"
        ...
        :modules {:main {:init-fn my.app/init}}}}}
```

`shadow-cljs` seguira a dependência de grafo a partir do conjunto raíz do ponto de entrada em `:entries``
para encontrar tudo que é preciso para na verdade compilar e incluir na saída. Namespaces que não são requeridas não serão incluidas.

A configuração acima vai criar um arquivo `public/js/main.js`. Durante o desenvolvimento haverá um diretório adicional `public/js/cljs-runtime` com vários arquivos. Esse diretório não é requerido para builds `release`.

== Code Splitting [[CodeSplitting]]

Declarando mais que um Module requer um pouquinho de configuração estatica adicional então o Compiler pode descobrir como os Modulos são relacionado uns com os outros e como vão ser carregados mais tarde.

Além de `:entries` você vai precisar declar quais modulos dependes de quais (via `:depends-on`). Como você estrutura depende inteiramente das suas necessidades e não existe uma solução bala de prata nessa situação.

Digamos que você tenha um website tradicional com pagínas diferentes.

- `www.acme.com` - serve a página inicial
- `www.acme.com/login` - serve o formulário de login
- `www.acme.com/protected` - sessão protegida que só é disponível quando o usuário ta logado

Uma boa configuração para isso seria ter um módulo common que é compartilhado entre todas as páginas. Então uma para cada página.

.Exemplo de config com múltiplos módulos `:modules`
```clojure
{...
 :output-dir "public/js"
 :modules
 {:shared
  {:entries [my.app.common]}
  :home
  {:entries [my.app.home]
   :depends-on #{:shared}}
  :login
  {:entries [my.app.login]
   :depends-on #{:shared}}
  :protected
  {:entries [my.app.protected]
   :depends-on #{:shared}}
```

DICA: É possível deixar o `:entries` do modulo `:shared` vázio para permitir que o compilador descubra quais namespaces são compartilhados entre os outros módulos.

.Estrutura de arquivos geradas
```text
.
└── public
    └── js
        ├── shared.js
        ├── home.js
        ├── login.js
        └── protected.js
```

No seu HTML para a página inicial você então sempre inclui o `shared.js` em cada página e outros condicionalmente dependen de qual página o usuário está online.

.HTML para a página de `/login`
```html
<script src="/js/shared.js"></script>
<script src="/js/login.js"></script>
```

IMPORTANTE: Os arquivos `.js` devem ser incluidos na ordem correta. O <<BrowserManifest, `manifest.edn`>> pode ajudar com isso.

=== Carregando código dinamicamente

Atualmente os Sigle-Page-Apps (SPA) estão se tornando mais populares e eles trabalham de maneira semelhante ao invés de deixar o servidor decidir qual JS incluir ao Client ele faz isso por si só.

==== Usando shadow-cljs's built-in Loader Support

O compiler suporta gerar o dado requerido usando o `shadow.loader` namespace. Ele expõe uma simples interface que permite carregar modules sob demanda em tempo de compilação.

Você apenas precisa adicionar o `:module-loader true` ao seu build config. O loader vai sempre ser injetado em um módulo padrão (aquele do qual todo mundo depende).

No runtime você deve usar o namespace `shadow.loader` para carregar os modulos. Você deve também carregar o módulo avidamente apenas usando uma tag `<script>` na sua página.

```
{...
 :builds
   {:app
     {:target :browser
      ...
      :module-loader true
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}
```

Se você teve o seguinte entry point:

```
(ns my.app
  (:require [shadow.loader :as loader]))

(defn fn-to-call-on-load []
  (js/console.log "extra loaded"))

(defn fn-to-call-on-error []
  (js/console.log "extra load failed"))
```

Então a expressão a seguir pode ser usada para carregar o código:

.Carregando um módulo
```
;; load returns a goog.async.Deferred, and can be used like a promise
(-> (loader/load "extra")
    (.then fn-to-call-on-load fn-to-call-on-error))
```

.Carregando muitos módulos
```
;; must be a JS array, also returns goog.async.Deferred
(loader/load-many #js ["foo" "bar"])
```

.Incluindo uma callback
```
(loader/with-module "extra" fn-to-call-on-load)
```

Você pode checar se um módulo é carregado usando `(loaded? "module-name")`.

===== Loader Costs

Using the loader is very lightweight. It has a few dependencies which you may not be otherwise using. In practice using `:module-loader true` adds about 8KB gzip'd to the default module. This will vary depending on how much of `goog.net` and `goog.events` you are already using, and what level of optimization you use for your release builds.

==== Using the Standard ClojureScript API

The generated code is capable of using the standard ClojureScript `cljs.loader` API. See the
https://clojurescript.org/news/2017-07-10-code-splitting[documentation] on the ClojureScript
website for instructions.

The advantage of using the standard API is that your code will play well with others. This
may be of particular importance to library authors. The disadvantage is that the dynamic module
loading API in the standard distribution is currently somewhat less easy-to-use than the
support in `shadow-cljs`.

== Output Wrapper [[output-wrapper]]

*Release builds only*: The code generated by the Closure Compiler `:advanced` compilation will create a lot of global variables which has the potential to create conflicts with other JS running in your page. To isolate the created variables the code can be wrapped in an anonymous function to the variables only apply in that scope.

`release` builds for `:browser` with only one `:modules` are wrapped in `(function(){<the-code>}).call(this);` by default. So no global variables are created.

When using multiple `:modules` (a.k.a <<CodeSplitting, code splitting>>) this is not enabled by default since each module must be able to access the variables created by the modules it depends on. The Closure Compiler supports an additional option to enable the use of an output wrapper in combination with multiple `:modules` named `:rename-prefix-namespace`. This will cause the Compiler to scope all "global" variables used by the build into one actual global variable. By default this is set to `:rename-prefix-namespace "$APP"` when `:output-wrapper` is set to `true`.

```clojure
{...
 :builds
 {:target :browser
  ...
  :compiler-options
  {:output-wrapper true
   :rename-prefix-namespace "MY_APP"}}}
```

This will only create the `MY_APP` global variable. Since every "global" variable will now be prefixed by `MY_APP.` (e.g. `MY_APP.a` instead of just `a`) the code size can go up substantially. It is important to keep this short. Browser compression (e.g. `gzip`) helps reduce the overhead of the extra code but depending on the amount of global variables in your build this can still produce a noticeable increase.

IMPORTANT: Note that the created variable isn't actually useful directly. It will contain a lot of munged/minified properties. All exported (eg. `^:export`) variables will still be exported into the global scope and are not affect by this setting. The setting only serves to limit the amount of global variables created, nothing else. Do not use it directly.


== Web Workers

The `:modules` configuration may also be used to generate files intended to be used as a Web Workers.
You may declare any module as a Web Worker by setting `:web-worker true`. The
generated file will contain some additional bootstrap code which will load its dependencies
automatically. The way `:modules` work also ensures that code used only by the worker will also only
be in the final file for the worker. Each worker should have a dedicated CLJS namespace.

.An example of generating a web worker script
```
{...
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :asset-path "/js"
   ...
   :modules
   {:shared
    {:entries []}
    :main
    {:init-fn my.app/init
     :depends-on #{:shared}}
    :worker
    {:init-fn my.app.worker/init
     :depends-on #{:shared}
     :web-worker true}}
   :devtools {:browser-inject :main}
   }}}
```

The above configuration will generate `worker.js` which you can use to start the Web Worker.
It will have all code from the `:shared` module available (but not `:main`). The code in the
`my.app.worker` namespace will only ever execute in the worker. Worker generation happens in
both development and release modes.

Note that the empty `:entries []` in the `:shared` module will make it collect all the code shared between the `:main` and `:worker` modules.

The `:devtools {:browser-inject :main}` is currently required to tell the compiler where the browser devtools/hud should be added to. It defaults to adding them to the "base" module which would be `:shared` in this case. Since that contains code not compatible with the Worker environment we need to move it.

.Sample echo worker
```
(ns my.app.worker)

(defn init []
  (js/self.addEventListener "message"
    (fn [^js e]
      (js/postMessage (.. e -data)))))
```

.Sample using the worker
```
(ns my.app)

(defn init []
  (let [worker (js/Worker. "/js/worker.js")]
    (.. worker (addEventListener "message" (fn [e] (js/console.log e))))
    (.. worker (postMessage "hello world"))))
```

IMPORTANT: Since we now have a `:shared` module you must ensure to load it properly in your HTML. If you just load `main.js` you will get an error.

.HTML Loading shared.js and main.js
```
<script src="/js/shared.js"></script>
<script src="/js/main.js"></script>
```

== Cacheable Output

In a web setting it is desirable to cache `.js` files for a very long time to avoid extra request. It is common
practice the generate a unique name for the `.js` file for every released version. This changes the URL used to
access it and thereby is safe to cache forever.

=== Release Versions [[release-version]]

Creating unique filenames for each release can be done via the `:release-version` config setting. Generally you'll pass this in from the command line via <<config-merge, --config-merge>>.

```
shadow-cljs release app --config-merge '{:release-version "v1"}'
```

.Example :modules config
```
{...
 :builds
   {:app
     {:target :browser
      ...
      :output-dir "public/js"
      :asset-path "/js"
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}
```

This would create the `main.v1.js` and `extra.v1.js` files in `public/js` instead of the usual `main.js` and `extra.js`.

You can use manual versions or something automated like the `git` sha at the time of the build. Just make sure that you bump whatever it is once you shipped something out to the user since with caching they won't be requesting newer versions of old files.

=== Filenames with Fingerprint-Hash [[NameHashing]]

You can add `:module-hash-names true` to your build config to automatically create a MD5
signature for each generated output module file. That means that a `:main` module will generate
a `main.<md5hash>.js` instead of just the default `main.js`.

`:module-hash-names true` will include the full 32-length md5 hash, if you prefer a shorter version you can specify a
number between 1-32 instead (eg. `:module-hash-names 8`). Be aware that shortening the hash may increase the chances
of generating conflicts. I recommend using the full hash.

.Example :module-hash-names config
```
{...
 :builds
   {:app
     {:target :browser
      ...
      :output-dir "public/js"
      :asset-path "/js"
      :module-hash-names true
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}
```

Instead of generating `main.js` it will now generate `main.<hash>.js` in the `:output-dir`.

Since the filename can change with every release it gets a little bit more complicated to include them
in your HTML. The <<BrowserManifest, Output Manifest>> can help with that.

== Output Manifest [[BrowserManifest]]

`shadow-cljs` generates a `manifest.edn` file in the configured `:output-dir`.
This file contains a description of the module config together with an extra `:output-name` property which
maps the original module name to actual filename (important when using the `:module-hash-names` feature).

.Sample output of manifest.edn when using hashed filenames.
```
[{:module-id :common,
  :name :common,
  :output-name "common.15D142F7841E2838B46283EA558634EE.js",
  :entries [...],
  :depends-on #{},
  :sources [...]}
 {:module-id :page-a,
  :name :page-a,
  :output-name "page-a.D8844E305644135CBD5CBCF7E359168A.js",
  :entries [...],
  :depends-on #{:common},
  :sources [...]}
 ...]
```

The manifest contains all `:modules` sorted in dependency order. You can use it to map the `:module-id` back to the
actual generated filename.

Development builds also produce this file and you may check if for modifications to
know when a new build completed. `:module-hash-names` does not apply during development so you'll get the usual
filenames.

You can configure the name of the generated manifest file via the `:build-options :manifest-name` entry. It defaults to
`manifest.edn`. If you configure a filename with `.json` ending the output will be JSON instead of EDN. The file will
be relative to the configured `:output-dir`.

.Example manifest.json config
```
{...
 :builds
   {:app
     {:target :browser
      ...
      :build-options {:manifest-name "manifest.json"}
      :modules {:main  {:entries [my.app]}
                :extra {:entries [my.app.extra]
                        :depends-on #{:main}}}}}}
```

== Development Support

The `:devtools` section of the configuration for `:browser` supports a few additional
options for configuring an optional dev-time HTTP server for a build and CSS reloading.

=== Heads-Up Display (HUD) [[hud]]

The `:browser` target now uses a HUD to display a loading indicator when a build is started. It will also display warnings and errors if there are any.

You can disable it completely by setting `:hud false` in the `:devtools` section.

You may also toggle certain features by specifying which features you care about via setting `:hud #{:errors :warnings}`. This will show errors/warnings but no progress indicator. Available options are `:errors`, `:warnings`, `:progress`. Only options included will be enabled, all other will be disabled.

==== Opening Files [[open-file-command]]

Warnings include a link to source location which can be clicked to open the file in your editor. For this a little bit of config is required.

You can either configure this in your `shadow-cljs.edn` config for the project or globally in your home directory under `~/.shadow-cljs/config.edn`.

.`:open-file-command` configuration
```clojure
{:open-file-command
 ["idea" :pwd "--line" :line :file]}
```

The `:open-file-command` expects a vector representing a very simple DSL. Strings are kept as they are and keyword are replaced by their respective values. A nested vector can be used in case you need to combine multiple params, using `clojure.core/format` style pattern.

The above example would execute
```bash
$ idea /path/to/project-root --line 3 /path/to/project-root/srv/main/demo/foo.cljs
```

.`emacsclient` example
```
{:open-file-command
 ["emacsclient" "-n" ["+%s:%s" :line :column] :file]}
```

```bash
$ emacsclient -n +3:1 /path/to/project-root/srv/main/demo/foo.cljs
```

The available replacement variables are:

[Horizontal]
`:pwd`::
Process Working Directory (aka project root)

`:file`::
Absolute File Path

`:line`::
Line Number of Warning/Error

`:column`::
Column Number

`:wsl-file`::
Translated WSL file path. Useful when running `shadow-cljs` via WSL Bash. Translates a `/mnt/c/Users/someone/code/project/src/main/demo/foo.cljs` path into `C:\Users\...`

`:wsl-pwd`::
Translated `:pwd`



=== CSS Reloading

The Browser devtools can also reload CSS for you. This is enabled by default and in most cases requires no additional
configuration when you are using the built-in <<dev-http, development HTTP servers>>.

Any stylesheet included in a page will be reloaded if modified on the filesystem. Prefer using absolute paths but relative paths should work as well.

.Example HTML snippet
```html
<link rel="stylesheet" href="/css/main.css"/>
```

.Example Hiccup since we aren't savages
```
[:link {:rel "stylesheet" :href "/css/main.css"}]
```

.Using the built-in dev HTTP server
```
:dev-http {8000 "public"}
```

This will cause the browser to reload `/css/main.css` when `public/css/main.css` is changed.

`shadow-cljs` currently provides no support for directly compiling CSS but the usual tools will work and should
be run separately. Just make sure the output is generated into the correct places.

When you are not using the built-in HTTP Server you can specify `:watch-dir` instead which should be a path to the
document root used to serve your content.

.Example :watch-dir config
```clojure
{...
    {:builds
      {:app {...
             :devtools {:watch-dir "public"}}}}
```

When your HTTP Server is serving the files from a virtual directory and the filesystem paths don't exactly match the path used in the HTML you may adjust the path by setting `:watch-path` which will be used as a prefix.

.Example `public/css/main.css` being served under `/foo/css/main.css`
```clojure
{...
 {:builds
  {:app
   {...
    :devtools {:watch-dir "public"
               :watch-path "/foo"}}}}
```

=== Proxy Support [[proxy-support]]

By default the devtools client will attempt to connect to the `shadow-cljs` process via the configured <<http, HTTP server>> (usually `localhost`). If you are using a reverse proxy to serve your HTML that might not be possible. You can set `:devtools-url` to configure which URL to use.

```
{...
 :builds
 {:app {...
        :devtools {:before-load  my.app/stop
                   :after-load   my.app/start
                   :devtools-url "https://some.host/shadow-cljs"
                   ...}}}}
```

`shadow-cljs` will then use the `:devtools-url` as the base when making requests. It is not the final URL so you must ensure that all requests starting with the path you configured (eg. `/shadow-cljs/*`) are forwarded to the host `shadow-cljs` is running on.


.Incoming Request to Proxy
```text
https://some.host/shadow-cljs/ws/foo/bar?asdf
```
.must forward to
```
http://localhost:9630/foo/bar?asdf
```

The client will make WebSocket request as well as normal XHR requests to load files. Ensure that your proxy properly upgrades WebSockets.

IMPORTANT: The requests must be forwarded to the main <<http, HTTP server>>, not the one configured in the build itself.

