O modo de desenvolvimento sempre tem saídas individuais para cada namespace, assim eles conseguem ser recarregados de maneira isolada.
Quando você estiver pronto pra fazer o deploy do código para um servidor você quer rodar o Closure Compiler
para gerar um único resultado minificado para cada <<Modules, module>>.

Por padrão os arquivos de saída do modo release deve ser apenas visto em substituição para os arquivos do
modo de desenvolvimento: não existe diferenças na maneira de incluir eles no HTML. Você deve usar 
<<NameHashing, filename hashing>> para melhorar as caracteristicas de chaching no navegador.

.Gerando Saída Minificada
```
$ shadow-cljs release build-id
```

== Configuração de Release

Geralmente você não vai precisar adicionar nenhuma configuração extra pra criar uma versão de release para seu build. A configuração padrão já captura tudo que é necessário e deveria apenas requerer configuração extra se você quer sobrescrever o padrão.

Cada `:target` já provê bons padrões otimizados para cada plataforma então você vai ter menos com o que se preocupar.

=== Otimizações [[Otimizações]]

Você pode escolher o nível de otimização usando a seção `:compiler-options` da configuração:

IMPORTANTE: Geralmente você não precisa configurar `:optimizations` desde que o `:target` já esteja no nível apropriado.

IMPORTANTE: `:optimizations` apenas aplicam quando usando o comando `release`. Builds de desenvolimento nunca são otimizadas pelo Closure Compiler. Elas são sempre configuradas para `:none`.

```clojure
{...
 :build
   {:build-id
     {...
      :compiler-options {:optimizations :simple}}}}
```

Veja o https://developers.google.com/closure/compiler/docs/compilation_levels[the Closure compiler's documentation]
para mais informações sobre os níveis de otimização disponíveis.

=== Release-Specifico vs. Configuração de desenvolvimento

Se você deseja ter valores de configurações separadas em um build quando rodando um build de release então você
pode sobrescrever as configurações incluindo um `:dev` e/ou seção `:release` no build:

.Exemplo do `shadow-cljs.edn` build config
```clojure
{:source-paths ["src"]
 :dependencies []
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :asset-path "/js"
   :modules {:base {:entries [my.app.core]}}

   ;; Here is some dev-specific config
   :dev {:compiler-options {:devcards true}}

   ;; Here is some production config
   :release {:compiler-options {:optimizations :simple}}}}}
```

== Externs [[externs]]

Desde que nós queremos que os builds sejam completamente otimizados pelo Closure Compiler precisamos lidar a compilação `:advanced` https://developers.google.com/closure/compiler/docs/api-tutorial3[Externs]. Externos representa pedaços de códigos que não são incluídos qaundo fazendo compilação `:advanced` . `:advanced` trabalha fazendo otimizações de todo oprograma mas existe algum código que não seja capaz de incluir, então externs informa ao Compiler sobre esse código. Sem o externs o Compiler deve renomear ou remover algum código que não deveria.

Tipicamente todas as dependências JS são estrangeiras e não serão passadas através do `:advanced` e assim requer Externs.

DICA: Externs são requeridos apenas para `:advanced`, ele não são requeridos no modo `:simple`.

TIP: Externs are only required for `:advanced`, they are not required in `:simple` mode.

=== Externs Inference [[infer-externs]]

To help deal with Externs the `shadow-cljs` compiler provides enhanced externs inference which can be enabled by setting `:infer-externs :auto` for your build.

.Example Config
```clojure
{...
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:infer-externs :auto}
   }}}}
```

With `:auto` the compiler will perform additional checks at compile time for your files only. It won't warn you about possible externs issues in library code. `:all` will enable it for everthing but be aware that you may get a lot of warnings.

When enabled you'll get warnings whenever the Compiler cannot figure out whether you are working with JS or CLJS code.

.Example Code
```
(defn wrap-baz [x]
  (.baz x))
```

.Example Warning
```text
------ WARNING #1 --------------------------------------------------------------
 File: ~/project/src/demo/thing.cljs:23:3
--------------------------------------------------------------------------------
  21 |
  22 | (defn wrap-baz [x]
  23 |   (.baz x))
---------^----------------------------------------------------------------------
 Cannot infer target type in expression (. x baz)
--------------------------------------------------------------------------------
```

In `:advanced` the compiler will be renaming `.baz` to something "shorter" and Externs inform the Compiler that this is an external property that should not be renamed.

`shadow-cljs` can generate the appropriate externs if you add a typehint to the object you are performing native interop on.

.Type-hint to help externs generation
```clojure
(defn wrap-baz [x]
  (.baz ^js x))
```

The `^js` typehint will cause the compiler to generate proper externs and the warning will go away. The property is now safe from renaming.

.Multiple interop calls
```clojure
(defn wrap-baz [x]
  (.foo ^js x)
  (.baz ^js x))
```

It can get tedious to annotate every single interop call so you can annotate the variable binding itself. It will be used in the entire scope for this variable. Externs for both calls will still be generated.

.Annotate `x` directly
```clojure
(defn wrap-baz [^js x]
  (.foo x)
  (.baz x))
```

IMPORTANT: Don't annotate everything with `^js`. Sometimes you may be doing interop on CLJS or ClosureJS objects. Those do not require externs. If you are certain you are working with a CLJS Object prefer using the `^clj` hint.
 It is not the end of the world when using `^js` incorrectly but it may affect some optimizations when a variable is not renamed when it could be.


Calls on globals do not require a typehint when using direct `js/` calls.

.No hint required, externs inferred automatically
```
(js/Some.Thing.coolFunction)
```

Calls on `:require` bindings are also inferred automatically.

.No hint required for `:as` and `:refer` bindings
```
(ns my.app
  (:require ["react" :as react :refer (createElement)]))

(react/createElement "div" nil "hello world")
(createElement "div" nil "hello world")
```

=== Manual Externs

Some libraries provide Externs as separate `.js` files. You can include them into your build via the `:externs` compiler options.

.Manual Externs Config
```
{...
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:externs ["path/to/externs.js" ...]}
   }}}
```

TIP: The compiler looks for files relative to the project root first. It will also attempt to load them from the classpath if no file is found.

=== Simplified Externs

Writing Externs by hand can be challenging and `shadow-cljs` provides a way to write a more convenient way to write them. In combination with `shadow-cljs check <your-build>` you can quickly add the missing Externs.

Start by creating a `externs/<your-build>.txt`, so build `:app` would be `externs/app.txt`. In that file each line should be one word specifying a JS property that should not be renamed. Global variables should be prefixed by `global:`

.Example externs/app.txt
```
# this is a comment
foo
bar
global:SomeGlobalVariable
```

In this example the compiler will stop renaming `something.foo()`, `something.bar()`.

== Code Stripping

The Closure Compiler supports removing unwanted code by name. This allows removing code that normal dead-code removal can't or won't remove. This is quite dangerous as it can remove code you actually care about but it can remove a lot of dev only code easily. It is grouped into 4 separate options of which pretty much only `:strip-type-prefixes` is relevant to ClojureScript but other may be useful as well.

.Example removing all uses of `cljs.pprint`
```
{...
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:strip-type-prefixes #{"cljs.pprint"}
   }}}
```

Each of these options is specified as a Set of Strings. Please note that all the names specified here are JS names so certain CLJS names must be munged. `my-lib.core` becomes `my_lib.core`.

[Horizontal]
`:strip-types`:: Allows removing deftype/defrecord declarations or uses. `#{"my.ns.FooBar}` removes `(defrecord FooBar [])`.
`:strip-type-prefixes`:: Removes everything starting with any of the given Prefixes. Allows removing entire CLJS namespaces.
`:strip-name-prefixes`:: Allows removing properties by prefix. `#{"log"}` removes `this.logX` or `(defn log-me [...])`
`:strip-name-suffixes`:: Allows removing properties by suffix. `#{"log"}` removes `this.myLog` or `(defn my-log [...])`

****
*DANGER: Be careful with these options. They apply to your entire build and may remove code you actually need. You may accidentally remove code in libraries not written by you. Always consider other options before using this.*
****


== Build Report

`shadow-cljs` can generate a detailed report for your `release` builds which includes a detailed breakdown of the included sources and how much they each contributed to the overall size.

A sample report can be found https://code.thheller.com/demos/build-report/huge.html[here].

```bash
$ npx shadow-cljs run shadow.cljs.build-report <build-id> <path/to/output.html>
# example
$ npx shadow-cljs run shadow.cljs.build-report app report.html
```

The above example will generate a `report.html` in the project directory for the `:app` build.

TIP: The generated `report.html` is entirely self-contained and includes all the required data/js/css. No other external sources are required.
