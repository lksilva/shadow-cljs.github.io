O modo de desenvolvimento sempre tem saídas individuais para cada namespace, assim eles conseguem ser recarregados de maneira isolada.
Quando você estiver pronto pra fazer o deploy do código para um servidor você quer rodar o Closure Compiler
para gerar um único resultado minificado para cada <<Modules, module>>.

Por padrão os arquivos de saída do modo release deve ser apenas visto em substituição para os arquivos do
modo de desenvolvimento: não existe diferenças na maneira de incluir eles no HTML. Você deve usar 
<<NameHashing, filename hashing>> para melhorar as caracteristicas de chaching no navegador.

.Gerando Saída Minificada
```
$ shadow-cljs release build-id
```

== Configuração de Release

Geralmente você não vai precisar adicionar nenhuma configuração extra pra criar uma versão de release para seu build. A configuração padrão já captura tudo que é necessário e deveria apenas requerer configuração extra se você quer sobrescrever o padrão.

Cada `:target` já provê bons padrões otimizados para cada plataforma então você vai ter menos com o que se preocupar.

=== Otimizações [[Otimizações]]

Você pode escolher o nível de otimização usando a seção `:compiler-options` da configuração:

IMPORTANTE: Geralmente você não precisa configurar `:optimizations` desde que o `:target` já esteja no nível apropriado.

IMPORTANTE: `:optimizations` apenas aplicam quando usando o comando `release`. Builds de desenvolimento nunca são otimizadas pelo Closure Compiler. Elas são sempre configuradas para `:none`.

```clojure
{...
 :build
   {:build-id
     {...
      :compiler-options {:optimizations :simple}}}}
```

Veja o https://developers.google.com/closure/compiler/docs/compilation_levels[the Closure compiler's documentation]
para mais informações sobre os níveis de otimização disponíveis.

=== Release-Specifico vs. Configuração de desenvolvimento

Se você deseja ter valores de configurações separadas em um build quando rodando um build de release então você
pode sobrescrever as configurações incluindo um `:dev` e/ou seção `:release` no build:

.Exemplo do `shadow-cljs.edn` build config
```clojure
{:source-paths ["src"]
 :dependencies []
 :builds
 {:app
  {:target :browser
   :output-dir "public/js"
   :asset-path "/js"
   :modules {:base {:entries [my.app.core]}}

   ;; Here is some dev-specific config
   :dev {:compiler-options {:devcards true}}

   ;; Here is some production config
   :release {:compiler-options {:optimizations :simple}}}}}
```

== Externs [[externs]]

Desde que nós queremos que os builds sejam completamente otimizados pelo Closure Compiler precisamos lidar a compilação `:advanced` https://developers.google.com/closure/compiler/docs/api-tutorial3[Externs]. Externos representa pedaços de códigos que não são incluídos qaundo fazendo compilação `:advanced` . `:advanced` trabalha fazendo otimizações de todo oprograma mas existe algum código que não seja capaz de incluir, então externs informa ao Compiler sobre esse código. Sem o externs o Compiler deve renomear ou remover algum código que não deveria.

Tipicamente todas as dependências JS são estrangeiras e não serão passadas através do `:advanced` e assim requer Externs.

DICA: Externs são requeridos apenas para `:advanced`, ele não são requeridos no modo `:simple`.

=== Inferência Externa [[infer-externs]]

Para ajudar a lidar com Externs o compilidador `shadow-cljs` provê uma inferência externa melhorada que pode ser habilitada configurando `:infer-externs :auto` para seu build.

.Exemplo do Config
```clojure
{...
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:infer-externs :auto}
   }}}}
```

Com `:auto` o compilador vai executar "checks" adicionais em tempo de compilação, apenas para seus arquivos. Isso não vai alertar você sobre possíveis problemas externos no código das bibliotecas. `:all` vai habilitar para qualquer coisa mas esteja consciênte que você vai receber uma grande quantidade de alertas.

Quando habilitade você vai vai receber alguns alertas sempre que o Compilador não descobrir se você esta trabalhando com código JS ou CLJS.

.Exemplo de código
```
(defn wrap-baz [x]
  (.baz x))
```

.Exemplo de alerta
```text
------ WARNING #1 --------------------------------------------------------------
 File: ~/project/src/demo/thing.cljs:23:3
--------------------------------------------------------------------------------
  21 |
  22 | (defn wrap-baz [x]
  23 |   (.baz x))
---------^----------------------------------------------------------------------
 Cannot infer target type in expression (. x baz)
--------------------------------------------------------------------------------
```

Na opção `:advanced` o compilador vai ser renomado `.baz` para algo mais "curto" e o Externs informa ao compilador que isso é uma propriedade externa que não deverá ser renomado.

`shadow-cljs` pode gerar o externs apropriado se você adicionar o typehint para o objeto que você está executando a interoperabilidade nativa.

.Type-hint par ajudar na geração de externs 
```clojure
(defn wrap-baz [x]
  (.baz ^js x))
```

O `^js` vai dizer ao compiler para gerar o extern adequado e o vai desaparecer. A propriedade agora está segura quando a renomear. 

.Multiplas chamadas de interoperabilidade
```clojure
(defn wrap-baz [x]
  (.foo ^js x)
  (.baz ^js x))
```

Pode ser tedioso declarar para cada chamada de interoperabilidade, então é possível declarar o bind da variabel. Isso será usando em todo o escopo pra essa variavel. Externs para ambas as chamadas ainda serão gerados.

.Declare `x` diretamente
```clojure
(defn wrap-baz [^js x]
  (.foo x)
  (.baz x))
```

IMPORTANT: Não declare tudo com `^js`. Algumas vezes você deve estar fazendo interop no CLJS ou nos objetos ClosureJS. Eles não requerem externs. Se você tiver certeza que está trabalhando com objetos CLJS é melhor usar o `^clj` hint.
Não se preocupe se você usar `^js` incorretamente mas ele deve afetar algumas otimizações quando uma variavel não for renomeada quando deveria ser.

Chamadas globais não requrem o typehint quando usando diretamente `js/`.

.No hint requerido, inferência externa é automátic
```
(js/Some.Thing.coolFunction)
```

Chamada no `:require` bindings são também inferidas automáticamente.

.Nenhum hint é requerido para `:as` e `:refer`
```
(ns my.app
  (:require ["react" :as react :refer (createElement)]))

(react/createElement "div" nil "hello world")
(createElement "div" nil "hello world")
```

=== Manual Externs

Some libraries provide Externs as separate `.js` files. You can include them into your build via the `:externs` compiler options.

.Manual Externs Config
```
{...
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:externs ["path/to/externs.js" ...]}
   }}}
```

TIP: The compiler looks for files relative to the project root first. It will also attempt to load them from the classpath if no file is found.

=== Simplified Externs

Writing Externs by hand can be challenging and `shadow-cljs` provides a way to write a more convenient way to write them. In combination with `shadow-cljs check <your-build>` you can quickly add the missing Externs.

Start by creating a `externs/<your-build>.txt`, so build `:app` would be `externs/app.txt`. In that file each line should be one word specifying a JS property that should not be renamed. Global variables should be prefixed by `global:`

.Example externs/app.txt
```
# this is a comment
foo
bar
global:SomeGlobalVariable
```

In this example the compiler will stop renaming `something.foo()`, `something.bar()`.

== Code Stripping

The Closure Compiler supports removing unwanted code by name. This allows removing code that normal dead-code removal can't or won't remove. This is quite dangerous as it can remove code you actually care about but it can remove a lot of dev only code easily. It is grouped into 4 separate options of which pretty much only `:strip-type-prefixes` is relevant to ClojureScript but other may be useful as well.

.Example removing all uses of `cljs.pprint`
```
{...
 :builds
 {:app
  {:target :browser
   ...
   :compiler-options {:strip-type-prefixes #{"cljs.pprint"}
   }}}
```

Each of these options is specified as a Set of Strings. Please note that all the names specified here are JS names so certain CLJS names must be munged. `my-lib.core` becomes `my_lib.core`.

[Horizontal]
`:strip-types`:: Allows removing deftype/defrecord declarations or uses. `#{"my.ns.FooBar}` removes `(defrecord FooBar [])`.
`:strip-type-prefixes`:: Removes everything starting with any of the given Prefixes. Allows removing entire CLJS namespaces.
`:strip-name-prefixes`:: Allows removing properties by prefix. `#{"log"}` removes `this.logX` or `(defn log-me [...])`
`:strip-name-suffixes`:: Allows removing properties by suffix. `#{"log"}` removes `this.myLog` or `(defn my-log [...])`

****
*DANGER: Be careful with these options. They apply to your entire build and may remove code you actually need. You may accidentally remove code in libraries not written by you. Always consider other options before using this.*
****


== Build Report

`shadow-cljs` can generate a detailed report for your `release` builds which includes a detailed breakdown of the included sources and how much they each contributed to the overall size.

A sample report can be found https://code.thheller.com/demos/build-report/huge.html[here].

```bash
$ npx shadow-cljs run shadow.cljs.build-report <build-id> <path/to/output.html>
# example
$ npx shadow-cljs run shadow.cljs.build-report app report.html
```

The above example will generate a `report.html` in the project directory for the `:app` build.

TIP: The generated `report.html` is entirely self-contained and includes all the required data/js/css. No other external sources are required.
