== NPM [[npm]]

https://www.npmjs.com/[npm] tem se tornado o package manager padrão para JavaScript. Quase todas as bibliotecas JS podem ser encontradas lá e o shadow-cljs provê uma integração desatada para acesssar esses packages.

=== Usando npm packages

Muito dos pacotes npm irão incluir algumas instruções em como usar o código atual. O "old" estilo CommonJS só precisa de chamadas do qual traduz diretamente:

```js
var react = require("react");
```

```
(ns my.app
  (:require ["react" :as react]))
```

Tanto faz o parâmetro "string" usado quando chamando require nos transferimos para o `:require` as-is. O apelido `:as` cabe a você. Uma vez que nós temos isso, podemos usar o código como qualquer outro namespace CLJS!

```
(react/createElement "div" nil "hello world")
```

No `shadow-cljs`: *sempre usa o `ns` from e tanto faz o apelido `:as` que você forneceu.* Você deve também usar `:refer` e `:rename`. Isso é diferente do que `:foreign-libs`/CLJSJS faz onde você inclui a coisa no namespace mas então usa um global `js/Thing` no seu código.

Alguns pacotes penas exporta uma única função da qual você chama diretamente usando `(:require ["thing" :as thing])` e então `(thing)`.

Mais recentemente alguns pacotes começam usando ES6 a declarção `import` em seus exemplos. Esses também são muito bem traduzidos 1:1 com uma pequena diferença relacionada ao export padrão.

A seguinte tabela pode ser usada para trandução:

IMPORTANTE: Essa tabela apenas se aplica se o código que você está rodando consome o pacote como um código ES6+. Se o código do pacote é um CommonJS o `:default` não deve ser aplicado. Veja a sessão abaixo para mais informações.

.ES6 import para CLJS
|===
|ES6 Import|CLJS Require

|`import defaultExport from "module-name";`
|`(:require ["module-name" :default defaultExport])`

|`import * as name from "module-name";`
|`(:require ["module-name" :as name])`

|`import { export } from "module-name";`
|`(:require ["module-name" :refer (export)])`

|`import { export as alias } from "module-name";`
|`(:require ["module-name" :rename {export alias}])`

|`import { export1 , export2 } from "module-name";`
|`(:require ["module-name" :refer (export1 export2)])`

|`import { export1 , export2 as alias2 , [...] } from "module-name";`
|`(:require ["module-name" :refer (export1) :rename {export2 alias2}])`

|`import defaultExport, { export [ , [...] ] } from "module-name";`
|`(:require ["module-name" :refer (export) :default defaultExport])`

|`import defaultExport, * as name from "module-name";`
|`(:require ["module-name" :as name :default defaultExport])`

|`import "module-name";`
|`(:require ["module-name"])`
|===

Perceba que anteriormente estavamos presos usando um bunde do qual incluia um monte de código que atualmente não é preciso. Agora estamos em uma situação melhor: Agumas bibliotecas estão empacotadas em uma maneira que permite que você inclue apenas as partes necessárias, levando a muito menos código no build final.

`react-virtualized` is a great example:

```js
// You can import any component you want as a named export from 'react-virtualized', eg
import { Column, Table } from 'react-virtualized'

// But if you only use a few react-virtualized components,
// And you're concerned about increasing your application's bundle size,
// You can directly import only the components you need, like so:
import AutoSizer from 'react-virtualized/dist/commonjs/AutoSizer'
import List from 'react-virtualized/dist/commonjs/List'
```

Com nossa melhoria de suporte podemos facilmente traduzir em:

```
(ns my-ns
  ;; all
  (:require ["react-virtualized" :refer (Column Table)])
  ;; OR one by one
  (:require ["react-virtualized/dist/commonjs/AutoSizer" :default virtual-auto-sizer]
            ["react-virtualized/dist/commonjs/List" :default virtual-list]))
```

==== Sobre :default Exports

A opção `:default` é atualmente apenas disponível com `shadow-cljs`, você pode https://dev.clojure.org/jira/browse/CLJS-2376[votar aqui] para esperançosamente tornar isso um padrão. Mas você pode sempre usar `:as alias` e então chamar `alias/default` se você preferir ficar totalmente compatível com o padrão CLJS.

Default exports são um acrescimo ao módules ECMAScript e não existe no código CommonJS. Algumas vezes você vai ver exemplos de `import Foo from "something"` quando o código é na verdade um código CommonJS. Nesses casos `(:require ["something" :default Foo])` não vai funcionar e invés disso `(:require ["something" :as Foo])` deve ser usado.

Se o `:require` não estiver funcionando da maneira esperada é recomendado tentar olhar ele na REPL.

```
$ shadow-cljs browser-repl (or node-repl)
...
[1:1]~cljs.user=> (require '["react-tooltip" :as x])
nil
[1:1]~cljs.user=> x
#object[e]
[1:1]~cljs.user=> (goog/typeOf x)
"function"
[1:1]~cljs.user=> (js/console.dir x)
nil
```

Desde que printar objetos JS nem sempre é útil (como visto acima) é possível usar `(js/console.dir x)` para conseguir uma representação mais útil no console do navegador. `goog/typeOf` também deve ser útil as vezes. Desde que o exemplo acima mostra `"function"` usando `:default` não deveria funcionar uma vez que o `:default` é basicamente uma syntax sugar para `x/default`.

=== Package Provider [[js-provider]]

`shadow-cljs` suporta diversas maneiras diferentes de incluir pacotes `npm` no seu build. Eles são configurados através das configurações `:js-options :js-provider`. Cada `:target` geralmente define aquele apropriado para seu build, na maioria das vezes você não vai precisar tocar nessa configuração.

Atualmente são suportados três providers:

[Horizontal]
`:require`:: Mapeado diretamente para a chamada de função JS `require("thing")`. É o padrão para todos os alvos `node.js` uma vez que ele pode resolver `require` nativamente em tempo de execução. O JS incluido não é processado de nenhuma maneira.
`:shadow`:: Resolve o JS através do `node_modules` e inclui uma versão minificada para cada arquivo referênciado no build. É o padrão para o target `:browser`. `node_modules` não passa pela compilação `:advanced`.
`:closure`:: Funciona de maneira parecida com o `:shadow` mas tenta processar todos os arquivos incluidos através do Closure Compiler CommonJS/ES6, facilidade de reescritas. Também são processado através da compilação `:advanced`.  

.`:shadow` vs `:closure`
****
Idealmente quermos usar `:closure` como nosso Provider de JS primário desde que ele vai rodar toda a aplicação através `:advanced` nos fornecendo o mais otimizado output. Contudo na prática a maioria dos códigos disponíveis via `npm` não é compátivel com as agressivas otimizações que a compilação `:advanced` faz. Eles também falham em compilar tudo ou expoem pequenos bugs em tempo de execução que são muito dificeis de identificar.

`:shadow` é uma ordenada solução paliativa que processa o código de maneira `:simple` e alcança um suporte confiável enquanto ainda consegue código razoavelmente otimizado. A saída é comparável (ou frequentemente melhor) a outras ferramentas como a gerada pelo `webpack` por exemplo.

Até suport em Closure ser mais confiável em `:shadow` é recomendado o JS provider para `:browser`.
****


.Exemplo de config parar usar `:closure` em um `:browser` build.
```clojure
{...
 :builds
 {:app
  {:target :browser
   ...
   :js-options {:js-provider :closure}
   }}}
```


=== Resolvendo pacotes [[js-resolve]]

Por padrão `shadow-cljs` vai resolver todos os requires `(:require ["thing" :as x])` seguinte a convensão `npm`. Isso significa que isso vai olhar o `<project>/node_modules/thing/package.json` e seguir o código de lá. Para customizar como isso funciona `shadow-cljs` expõe uma opção de configuração `:resolve` que permite você sobrescrever como as coisas são resolvidas.

==== Usando uma CDN [[js-resolve-global]]

Digamos que você já tenha React incluido na página via um CDN. Você deveria apenas começar usando `js/React` novamente mas nós paramos de fazer isso por uma boa razão. Ao invés disso você pode continuar a usar (:require ["react" :as react])` mas configura como resolve o "react"!

Aqui está um exemplo de config `shadow-cljs.edn` para tal construção:

```
{...
 :builds
 {:app
  {:target :browser
   ...
   :js-options
   {:resolve {"react" {:target :global
                       :global "React"}}}}

  :server
  {:target :node-script
   ...}}}
```

A build `app` vai agora usar uma instância do `React` global enquanto o `:server` build continua usando o pacote npm "react". Não há necessidade de violar o código pra fazer isso funcionar.

==== Redirecionando “require” [[js-resolve-npm]]

Algumas vezes você quer mais controle sobre quais pacotes `npm` estão na realidade dependendo da sua build. Você consegue "redirect" determinados requires do build config sem mudar o código. Isso é frequente útil se você não tem acesso ao fonte do qual seu pacote esta usando ou você apenas quer mudar ele para um build. 

```
{...
 :builds
 {:app
  {:target :browser
   ...
   :js-options
   {:resolve {"react" {:target :npm
                       :require "preact-compat"}}}
```

==== Limitações [[js-resolve-limitations]]

O `:shadow-js` e `:closure` tem total controle sobre `:resolve` e tudo mencionado acima funciona sem desvantagens. O `:js-provider :require` contudo, é mais limitado. Apenas o require inicial pode ser influênciado desde o padrão `require` está no controle depois disso. Isso significa que não é possível influênciar o que o pacote deve `require` internamente. É portanto não recomendado ser usado com targets que sua `require` diretamente (ex. `:node-script`).

.Redirecionando "react" para "preact"
```
{...
 :builds
 {:app
  {:target :node-script
   ...
   :js-options
   {:resolve {"react" {:target :npm
                       :require "preact-compat"}}}
```
.Exemplo use react-table
```
(ns my.app
  (:require
    ["react-table" :as rt]))
```

O exemplo acima funciona bem no navegador desde que cara `"react"` requerido seja substituido, incluindo o `"react"` requer `"react-table"` internamente. Para `:js-provider :require` contudo um `require("react-table")` será emitido e `node` esta controlando como isso é resolvido. Significando que isso será resolvido no padrão `"react"` e não o `"preact"` que tinhamos configurado.

=== Alternar diretório de módulos [[alt-node-modules]]

Por padrão `shadow-cljs` só olha para o `<project-dir>/node_modules` quando resolvendo pacotes JS. Isso pode ser configurado através da opção `:js-package-dirs` em `:js-options`. Isso pode ser aplicado globalmente ou por build.

Paths relativos serão resolvido para a raíz do projeto. Paths serão scaneados da esquerda para a direita e o primeiro pacote que combine será usado.

.Config global `shadow-cljs.edn`
```
{...
 :js-options {:js-package-dirs ["node_modules" "../node_modules"]}
 ...}
```

.Config aplicado para um único build

```
{...
 :builds
 {:app
  {...
   :js-options {:js-package-dirs ["node_modules" "../node_modules"]}}}}
```


== Lidando com arquivos .js [[classpath-js]]

****
*Atenção: Essa funcionalidade é um experimento!* É suportado atualmente em `shadow-cljs` e outras ferramentas CLJS podem gerar problemas se você tentar usar ela. Use isso colocando sua conta em risco. A funcionalidade foi inicialmente rejeitada a partir do CLJS core mas eu acredito ser útil e não deveria ter sido https://dev.clojure.org/jira/browse/CLJS-2061?focusedCommentId=46191&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-46191[anulada] sem um discussão mais longa.

CLJS tem uma alternada https://clojurescript.org/guides/javascript-modules[implementacão] que por sua vez não é suportada pelo `shadow-cljs`. Eu achei que essa implementação esta se perdendo em certos aspectos então eu optei por diferentes soluções. Feliz em discutir os prós/contra de ambas abordagens. 
****

Nós cobrimos como os pacotes <<npm, npm>> são usados mas você deve estar trabalhando no codebase que já tem um monte de Javascript puro e você não quer sobrescrever tudo em ClojureScript ainda. `shadow-cljs` 100% de interoperabilidade entre JavasScript e ClojureScript. O que significa que seu JS pode usar CLJS e o CLJS pode usar o JS.

Só é necessário apenas algumas convenções que você precisa seguir com a finalidade disso funcionar mas há chances de você já estar fazendo isso de qualquer maneira.

=== Requiring JS

We already covered how `npm` packages are accessed by their name but on the classpath we access `.js` files by either a full path or relative to the current namespace.

.Loading JS from the classpath
```clojure
(ns demo.app
  (:require
    ["/some-library/components/foo" :as foo]
    ["./bar" :as bar :refer (myComponent)]))
```

TIP: For string requires the extension `.js` will be added automatically but you can specify the extension if you prefer. Note that currently only `.js` is supported though.

Absolute requires like `/some-library/components/foo` mean that the compiler will look for a `some-library/components/foo.js` on the classpath; unlike `node` which would attempt to load the file from the local filesystem. The same classpath rules apply so the file may either be in your `:source-paths` or in some third-party `.jar` library you are using.

Relative requires are resolved by first looking at the current namespace and then resolving a relative path from that name. In the above example we are in `demo/app.cljs` to the `./bar` require resolves to `demo/bar.js`, so it is identical to `(:require ["/demo/bar"])`.

IMPORTANT: The files must not be physically located in the same directory. The lookup for the file appears on the classpath instead. This is unlike node which expects relative requires to always resolve to physical files.

.Example File Structure with Separate Paths
```text
.
├── package.json
├── shadow-cljs.edn
└── src
    └── main
        └── demo
            └── app.cljs
    └── js
        └── demo
            └── bar.js
```

=== Language Support

IMPORTANT: It is expected that the classpath only contains JavaScript that can be consumed without any pre-processing by the Compiler. `npm` has a very similar convention.

The Closure Compiler is used for processing all JavaScript found on the classpath using its `ECMASCRIPT_NEXT` language setting. What exactly this setting means is not well documented but it mostly represents the next generation JavaScript code which might not even be supported by most browsers yet. ES6 is very well supported as well as most ES7 features. Similarly to standard CLJS this will be compiled down to ES5 with polyfills when required.

=== JavaScript Dialects

Since there are many popular JavaScript dialects (JSX, CoffeeScript, etc) that are not directly parsable by the Closure Compiler we need to pre-process them before putting them onto the classpath. https://babeljs.io/[babel] is commonly used in the JavaScript world so we are going to use `babel` to process `.jsx` files as an example here.

.Example shadow-cljs.edn Config
```
{:source-paths
 ["src/main"
  "src/gen"]
 ...}
```

.Example File Structure
```text
.
├── package.json
├── shadow-cljs.edn
└── src
    └── main
        └── demo
            └── app.cljs
    └── js
        ├── .babelrc
        └── demo
            └── bar.jsx
```

IMPORTANT: Notice how `src/js` is not added to `:source-paths` which means it will not be on the classpath.

.src/js/demo/bar.jsx
```jsx
import React from "react";

function myComponent() {
  return <h1>JSX!</h1>;
}

export { myComponent };
```

We run https://babeljs.io/docs/usage/cli/[babel] to convert the files and write them to the configured `src/gen` directory. Which directory you use it up to you. I prefer `src/gen` for generated files.

```bash
$ babel src/js --out-dir src/gen
# or during development
$ babel src/js --out-dir src/gen --watch
```

`babel` itself is configured via the `src/js/.babelrc`. See the official https://babeljs.io/docs/plugins/transform-react-jsx/[example for JSX].

.JSX minimal .babelrc
```json
{
  "plugins": ["transform-react-jsx"]
}
```

Once `babel` writes the `src/gen/demo/bar.js` it will be available to use via ClojureScript and will even be hot loaded just like your ClojureScript sources.

IMPORTANT: `shadow-cljs` currently does not provide any support for running those transformation steps. Please use the standard tools (eg. `babel`, `coffeescript`, etc.) directly until it does.

=== Access CLJS from JS

The JS sources can access all your ClojureScript (and the Closure Library) directly by importing their namespaces with a `goog:` prefix which the Compiler will rewrite to expose the namespace as the default ES6 export.

```
import cljs, { keyword } from "goog:cljs.core";

// construct {:foo "hello world"} in JS
cljs.array_map(keyword("foo"), "hello world");
```

TIP: The `goog:` prefix currently only works for ES6 file. `require("goog:cljs.core")` does not work.

== Migrating cljsjs.* [[cljsjs]]

> CLJSJS is an effort to package Javascript libraries to be able to use them from within ClojureScript.

Since `shadow-cljs` can access <<npm, npm packages>> directly we do not need to rely on re-packaged https://github.com/cljsjs/packages[CLJSJS] packages.

However many CLJS libraries are still using CLJSJS packages and they would break with `shadow-cljs` since it doesn't support those anymore. It is however very easy to mimick those `cljsjs` namespaces since they are mostly build from `npm` packages anyways. It just requires one shim file that maps the `cljsjs.thing` back to its original `npm` package and exposes the expected global variable.

For React this requires a file like `src/cljsjs/react.cljs`:

```
(ns cljsjs.react
  (:require ["react" :as react]
            ["create-react-class" :as crc]))
```

```
(js/goog.object.set react "createClass" crc)
(js/goog.exportSymbol "React" react)
```

Since this would be tedious for everyone to do manually I created the https://github.com/thheller/shadow-cljsjs[`shadow-cljsjs`]
library which provides just that. It does not include every package but I’ll keep adding
them and contributions are very welcome as well.

NOTE: The `shadow-cljsjs` library only provides the shim files. You’ll still need to
`npm install` the actual packages yourself.


=== Why not use CLJSJS?

CLJSJS packages basically just take the package from `npm` and put them into a `.jar` and re-publish them via https://clojars.org[clojars]. As a bonus they often bundle Externs. The compiler otherwise does nothing with these files and only prepends them to the generated output.

This was very useful when we had no access to `npm` directly but has certain issues since not all packages are easily combined with others. A package might rely on `react` but instead of expressing this via `npm` https://github.com/cljsjs/packages/tree/master/material-ui[they] bundle their own `react`. If you are not careful you could end up including 2 different `react` versions in your build which may lead to very confusing errors or at the very least increase the build size substantially.

Apart from that not every `npm` package is available via CLJSJS and keeping the package versions in sync requires manual work, which means packages are often out of date.

`shadow-cljs` does not support CLJSJS at all to avoid conflicts in your code. One library might attempt to use the "old" `cljsjs.react` while another uses the newer `(:require ["react"])` directly. This would again lead to 2 versions of `react` on your page again.

So the only thing we are missing are the bundled Externs. In many instances these are not required due to improved <<infer-externs, externs inference>>. Often those Externs are generated using third-party tools which means they are not totally accurate anyways.

Conclusion: Use <<npm, npm>> directly. Use <<infer-externs, :infer-externs auto>>.
