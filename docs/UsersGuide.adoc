= Guia do usuário Shadow CLJS
:author: Thomas Heller and Tony Kay
:revdate: Jan 10, 2018
:revnumber: 1.0
:lang: en
:encoding: UTF-8
:doctype: book
:source-highlighter: coderay
:source-language: clojure
:toc: left
:toclevels: 3
:sectlinks:
:sectanchors:
:leveloffset: 1
:sectnums:
:imagesdir: assets/img
:scriptsdir: js
:imagesoutdir: assets/img

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
toc::[]
endif::[]

// TODO: Missing content
// - HUD
// - Undocumented global options
//    - http
//    - ssl
//    - cache-root
//    - open-file-command
//    - others???

include::intro.adoc[]

== Sobre o livro

=== Work in Progress

Está processo de construção. Se você encontrar algum error, por favor nos envie um PR, ou um issue com detalhes do problema.

=== Contribuindo

Os recursos para esse livro estão hospedado em https://github.com/shadow-cljs/shadow-cljs.github.io[Github].

=== Convenções usadas

Existem vários exemplos nesse livro. Muitas coisas usadas aqui deveriam ser óbvia para esse contexto,
mas para prevenir mal-entendidos é importante conhecer as intenções do autor.

Quando exemplos de command-line são dados, devemos incluir comentários BASH (começando com `#`), e
normalmente incluir o padrão de usuário UNIX `$` para indicar separação do comando a partir da saída.

```bash
# Um breve comentário. Esse comando lista arquivos:
$ ls -l
shadow-cljs.edn
project.clj
...
```

Muito dos examples estão no arquivo de configuração do compilador. Esse arquivo contém um mapa EDN. Onde já discutimos opções obrigatórias e iremos frequentemente omitir eles pro questão de clareza. Nesse caso iremos na verdade incluir três pontinhos para indicar "conteúdo é obrigatório mas não é nosso foco atual":

.Exemplo 1. Especificar dependências
```
{:dependencies [[lib "1.0"]]}
```

.Exemplo 2. Adicionar source paths
```
{...
 :source-paths ["src"]
 ...}
```

Isso nos permite incluir contexto suficiente para entender a configuração aninhada:


.Exemplo 3. Opção aninhada
```
{...
 :builds {:build-id {...
                     :output-dir "resources/public/js"}}}
```

Exemplos de código devem ser similarmente encurtados.


= Instalação

== Padrão via `npm`

Você vai precisar:

- https://nodejs.org[`node.js`] (v6.0.0+, ou versões mais recentes)
- https://www.npmjs.com[`npm`] ou https://www.yarnpkg.com[`yarn`]
- Alguma SDK Java (Versão 8 ou superior). http://openjdk.java.net/install/[OpenJDK] ou http://www.oracle.com/technetwork/java/javase/downloads/index.html[Oracle]

.NPM
```bash
$ npm install --save-dev shadow-cljs
$ npm install -g shadow-cljs
```

.Yarn
```bash
$ yarn add --dev shadow-cljs
$ yarn global add shadow-cljs
```

== Biblioteca

Apesar de ser recomendado rodar a versão padrão via `npm` também é possível embutir `shadow-cljs` em qualquer outra ferramenta JVM (eg. `lein`, `boot`, ...).

O artefato pode ser encontrado em

image::https://img.shields.io/clojars/v/thheller/shadow-cljs.svg[link=https://clojars.org/thheller/shadow-cljs]
image::https://img.shields.io/npm/v/shadow-cljs.svg[link=https://github.com/thheller/shadow-cljs]

include::usage.adoc[]

include::repl.adoc[]

= Configuração [[config]]

`shadow-cljs` é configurado por um arquivo `shadow-cljs.edn` na raíz do projeto. Você pode
criar um template padrão rodando `shadow-cljs init`. Isso deve conter um map com alguma configuração
global e um `:builds`, entrada para todos seus builds.

```
{:source-paths [...]
 :dependencies [...]
 :builds {...}}
```

Um exemplo de configuração poderia parecer tal como:

```clojure
{:dependencies
 [[reagent "0.8.0-alpha2"]]

 :source-paths
 ["src"]

 :builds
 {:app {:target :browser
        :output-dir "public/js"
        :asset-path "/js"
        :modules {:main {:entries [my.app]}}}}}
```

A estrutura desse exemplo poderia parecer com:
```text
.
├── package.json
├── shadow-cljs.edn
└── src
    └── my
        └── app.cljs
```

== Source Paths [[source-paths]]

`:source-paths` configura o classpath da JVM. O compiler vai usar esse config para encontrar arquivos Clojure(Script) (eg `.cljs`).

Está tudo bem colocar qualquer coisa em um source path mas você não pode usar multiplos se você quiser "agrupar" arquivos fonte de uma determinada maneira. É útil se vocie quiser manter seus testes separados por exemplo.

.Using multiple source paths
.Usando multiplos source paths
```
{:source-paths ["src/main" "src/test"]
 ...}
```

.Estrutura de arquivo
```text
.
├── package.json
├── shadow-cljs.edn
└── src
    └── main
        └── my
            └── app.cljs
    └── test
        └── my
            └── app_test.cljs
```

Não é recomendado separar os arquivos fonte por extensão (eg. `src/clj`, `src/cljs`, `src/cljc`). Por alguma razão isso é amplamente usado em projetos CLJS mas isso só deixa as coisas mais difíceis de usar.

== Dependencies

=== Clojure(Script)

As dependência são gerenciadas através da key `:dependencia` na raíz do arquivo de configuração `shadow-cljs.edn`. Utiliza a mesma notação que outras ferramentas Clojure como `lein` e `boot`

Cada dependência é escrita como um vetor usando `[nome-biblioteca "versão"]` aninhados em um vetor exterior.


.Exemplo :dependencies
```clojure
{:source-paths ["src"]
 :dependencies [[reagent "0.9.1"]]
 :builds ...}
```
Perceba que o caminho de origem é *only* especificado apenas uma vez na estrutura. O sistema utilizará grafos de dependência nos namespace para determinar qual código será necessário no final do output para uma determinada build.

=== JavaScript [[npm-install]]

`shadow-cljs` integrates fully with the https://www.npmjs.com/[`npm`] ecosystem to manage JavaScript dependencies.

É possível utilizar `npm` ou `yarn` para gerenciar as dependência, por favor recorra as respectivas documentações.

[horizontal]
npm:: https://docs.npmjs.com/
yarn:: https://yarnpkg.com/en/docs

Ambas gerenciam as dependência através do arquivo `package.json`. Quase sempre o pacote disponível via `npm` vai explicar how instalar ele. Essas instruções agora são aplicadas ao `shadow-cljs` também.

.Instalando um pacote JavaScript
```bash
# npm
$ npm install the-thing

# yarn
$ yarn add the-thing
```

Não é preciso nada mais. As dependências serão adicionadas para o arquivo `package.json` e isso será usado para gerênciar as dependências.

TIP: Se não existe um `package.json` ainda, rode o comando `npm init` a partir do terminal.

==== Ta faltando dependências JS?

Muitas bibliotecas ClojureScript ainda não declaram os pacotes `npm`, ainda usam o <<cljsjs, CLJSJS>>. Nós queremos usar `npm` diretamente o que significa que você deve instalar manualmente os pacotes `npm` até as bibliotecas declararem o `:npm-deps`.

```text
The required JS dependency "react" is not available, it was required by ...
```

Isso significa que você deve instalar o React `npm install react`.

TIP: Nesse caso do `react`, é necessário esses três pacotes: `npm install react react-dom create-react-class`.

== Configuração do usuário [[user-config]]

A maioria das configurações serão feitas no projeto de maneira automática através do `shadow-cljs.edn` mas algumas configurações devem ser user-dependent. Ferramentas como https://docs.cider.mx[CIDER] deve solicitar a dependência adicional `cider-nrepl` da qual seria inútil para a pessoa que usar Cursive quando adicionando essa dependência via `shadow-cljs.edn`.
 
Um restrito conjunto de opções configuração pode ser adicionado para `~/.shadow-cljs/config.edn`dos quais vai aplicar para todos os projetos construídos nessa máquina.

Adicionar dependência é permitido via a key `:dependencies`. Perceba que as dependências adicionadas aqui serão aplicadas a TODOS os projetos. Mantenha só os pacotes relacionados as dependências aqui. Tudo que é relevante a build deve permanecer em `shadow-cljs.edn` de outra maneira as coisas não serão compiladas pra outros usuários.
Essas dependências serão automaticamente ser adicionadas quando usando `deps.edn` ou `lein` também.

.Exemplo ~/.shadow-cljs/config.edn
```
{:dependencies
 [[cider/cider-nrepl "0.21.1"]]}
;; this version may be out of date, check whichever is available
```

Quando usando `deps.edn` para resolver dependências você deve querer algumas vezes ativar apelidos adicionais. Isso pode ser feito através `:deps-aliases`.

```
;; shadow-cljs.edn in project
{:deps {:aliases [:cljs]}}

;; ~/.shadow-cljs/config.edn
{:deps-aliases [:cider]}
```
Isso vai fazer o comando `shadow-cljs` usar o apelido `[:cider :cljs]` no projeto usando `deps.edn`. Isso deve ser útil se você tem um apelido adicional `:cider` no seu `~/.clojure/deps.edn`.

Por padrão o server-mode `shadow-cljs` lançará o servidor nREPL embedado do qual você não precisa. É possível desabilitar essa configuração `:nrepl false` nas configurações de usuário.  

O outro valor aceito para a configuração de usuário é o <<open-file-command, :open-file-command>>. Nenhuma outra opção atualmente terá um efeito aqui.

== Server Options

Essa sessão é para as outras opções que configura a instância do servidor `shadow-cljs`. É opcional.

=== nREPL [[nREPL]]

O `shadow-cljs` <<server-mode, server>> provê um servidor https://nrepl.org[nREPL] via TPC. Se você olhar a mensagem de startup você vera a porta do nREPL, e a porta também está salva no `target/shadow-cljs/nrepl.port`:

```bash
$ shadow-cljs watch app
shadow-cljs - HTTP server available at http://localhost:8600
shadow-cljs - server version: <version> running at http://localhost:9630
shadow-cljs - nREPL server started on port 64967
shadow-cljs - watching build :app
[:app] Configuring build.
[:app] Compiling ...
```

É possível configurar a porta e o middleware adicional com `shadow-cljs.edn`:

```clojure
{...
 :nrepl {:port 9000
         :middleware []} ; optional list of namespace-qualified symbols
 ...}
```

O arquivo de configuração padrão está em `~/.nrepl/nrepl.edn` ou `.nrepl.edn` também carregado no startup e pode ser usado para configurar o `:middleware`.

Se o popular middleware https://github.com/clojure-emacs/cider-nrepl[cider-nrepl] é encontrado no classpath (incluido no `:dependencies`), será usado automaticamente. Nenhuma configuração adicional é necessária. Pode ser desabilitada pela configuração `:nrepl {:cider false}`.



Você deve configurar o namespace que vai iniciar a aplicação quando conectando pela configuração `:init-ns` na opção `:nrepl`. O padrão para `shadow.user`.

```clojure
{...
 :nrepl {:init-ns my.repl}
 ...}
```

O servidor nREPL pode ser desabilitado configurando `:nrepl false`.

==== Usando nREPL

Quando conectando para o servidor nREPL a conexão sempre inicia como um Clojure REPL. Trocar para um CLJS REPL funciona de maneira semelhante para ao <<cljs-repl, non-nREPL version>>. Primeiro o `watch` para uma determinada build precisa ser iniciada e então nós precisamos selecionar essa build para trocar para a sessão do nREPL atual para que ele build. Depois de selecionar o build tudo será avaliado em ClojureScript ao invés de Clojure.

```repl
(shadow/watch :the-build)
(shadow/repl :the-build)
```

Dica: Use `:cljs/quit` to voltar ao Clojure.

==== Servidor nREPL Embedado

Quando você usa `shadow-cljs` embedado em outra ferramenta que provê o próprio servidor nREPL (eg. `lein`) você precisa configurar o middleware `shadow-cljs`. De outra forma você não será capaz de trocar entre as REPLs CLJ e CLJS.

.Exemplo Leiningen `project.clj`
```clojure
(defproject my-amazing-project "1.0.0"
  ...
  :repl-options
  {:init-ns shadow.user ;; or any of your choosing
   :nrepl-middleware
   [shadow.cljs.devtools.server.nrepl/middleware]}
  ...)
```

Dica: Precisa começar o <<embedded, embedded server>> manualmente antes de usar o CLJS REPL.

=== Socket REPL [[socket-repl]]

Um socket Clojure REPL é iniciado automaticamente em server-mode e usa uma porta randômica por padrão. Ferramentas podem encontrar a porta que foi iniciada checando `.shadow-cljs/socket-repl.port` do qual vai conter o número da porta.

É possível configurar uma porta fixa através do `shadow-cljs.edn`.

```clojure
{...
 :socket-repl
 {:port 9000}
 ...}
```

O Socket REPL pode ser desabilitado pela configuração `:socket-repl false`.

=== SSL

O servidor HTTP `shadow-cljs` suporta SSL. Ele requer uma Keystore Java que provê uma chave privada e certificado.

.`shadow-cljs.edn` com SSL configurado
```
{...
 :ssl {:keystore "ssl/keystore.jks"
       :password "shadow-cljs"}
 ...}
```

O exemplo acima são padrão então se você quiser usar ele, tudo bem apenasar configurar `:ssl {}`.

É possível criar uma Keystore usando o comando java `keytool`. Criando um certificado self-signed é também possível mas um pouco complicado.

- https://gist.github.com/jchandra74/36d5f8d0e11960dd8f80260801109ab0[OpenSSL] instruções para Linux e Windows (via WSL)
- https://certsimple.com/blog/localhost-ssl-fix[macOS] instruções

O certificado criado `Certificates.p12` (macOS) ou `localhost.pfx` (Linux, Windows) pode ser ligado dentro do requerido `keystore.jks` através do `keytool`.

```bash
$ keytool -importkeystore -destkeystore keystore.jks -srcstoretype PKCS12 -srckeystore localhost.pfx
```

IMPORTANTE: Você deve gerar o Certificado com a SAN (Subject Alternative Name) para "localhost" (ou qualquer que seja que você quer usar). SAN é obrigatório para Chrome para o Certificado confiável e não mostra alertas. A senha usada quando exportando deve combinar a senha assinada para o Keystore.

// TODO: guia completo, outras plataformas

=== Primary HTTP(S) [[http]]

The `shadow-cljs` server starts one primary HTTP server. It is used to serve the UI and websockets used for Hot Reload and REPL clients. By default it listens on Port 9630. If that Port is in use it will increment by one and attempt again until an open Port is found.

.Startup message indicating the Port used
```bash
shadow-cljs - server running at http://0.0.0.0:9630
```

When `:ssl` is configured the server will be available via `https://` instead.

TIP: The server automatically supports HTTP/2 when using `:ssl`.

If you prefer to set your own port instead you can do this via the `:http` config.

.`shadow-cljs.edn` with `:http` config
```
{...
 :http {:port 12345
        :host "my.machine.local"}
 ...}
```

`:ssl` switches the server to server `https://` only. If you want to keep the `http://` version you can configure a separate `:ssl-port` as well.

```
{...
 :http {:port 12345
        :ssl-port 23456
        :host "localhost"}
 ...}
```

=== Development HTTP(S) [[dev-http]]

`shadow-cljs` can provide additional basic HTTP servers via the `:dev-http` config entry. By default these will serve all static files from the configured paths, and fall back to `index.html` when a resource is not found (this is what you typically want when developing an application which uses browser push state).

These servers are started automatically when `shadow-cljs` is running in server mode. They are not specific to any build and can be used to serve files for multiple builds as long as a unique `:output-dir` is used for each.

IMPORTANT:: These are just generic web servers that server static files. They are not required for any live-reload or REPL logic. Any webserver will do, these are just provided for convenience.

.Basic example serving the `public` directory via `http://localhost:8000`
```
{...
 :dev-http {8000 "public"}
 :builds {...}}
```

`:dev-http` expects a map of `port-number` to `config`. The `config` supports several shortcuts for the most common scenarios.

.Serve directory from filesystem root
```
:dev-http {8000 "public"}
```

.Serve from classpath root
```
:dev-http {8000 "classpath:public"}
```

This would attempt to find a request to `/index.html` via `public/index.html` on the classpath. Which may include files in `.jar` files.

.Serve from multiple roots
```
:dev-http {8000 ["a" "b" "classpath:c"]}
```

This would first attempt to find `<project-root>/a/index.html` then `<project-root>/b/index.html` then `c/index.html` on the classpath. If nothing is found the default handler will be called.

The longer config version expects a map and the supported options are:

`:root`:: (String) The path from which to serve requests. Paths starting with `classpath:` will serve from the classpath instead of the filesystem. All filesystem paths are relative to the project root.
`:roots`:: (Vector of Strings) If you need multiple root paths, use instead of `:root`.
`:ssl-port`:: When `:ssl` is configured use this port for ssl connections and server normal HTTP on the regular port. If `:ssl-port` is not set but `:ssl` is configured the default port will only server SSL requests.
`:host`:: Optional. The hostname to listen on. Defaults to localhost.
`:handler`:: Optional. A fully qualified symbol. A `(defn handler [req] resp)` that is used
if a resource is not found for the given request. Defaults to `shadow.http.push-state/handle`.

The following two options only apply when using the default, built-in handler and typically do not need to be changed:

`:push-state/headers`:: (optional) A map of HTTP headers to respond with. Defaults to `text/html` standard headers.
`:push-state/index`:: (optional) The file to serve. Defaults to `index.html`.


```clojure
{...
 :dev-http
 {8080 {:root "public"
        :handler my.app/handler}}}
```

==== Reverse Proxy Support [[dev-http-proxy]]

By default the dev server will attempt to serve requests locally but sometimes you may want to use an external web server to serve requests (eg. API request). This can be configured via `:proxy-url`.

```
{...
 :dev-http
 {8000
  {:root "public"
   :proxy-url "https://some.host"}}}
```

A request going to `http://localhost:8000/api/foo` will serve the content returned by `https://some.host/api/foo` instead. All request that do not have a local file will be served by the proxied server.

Additional optional Options to configure the connection handling are:
[Horizontal]
`:proxy-rewrite-host-header`:: boolean, defaults to true. Determines whether the original Host header will be used or the one from the `:proxy-url`. `localhost` vs `some.host` using the example above.
`:proxy-reuse-x-forwarded`:: boolean, defaults to false. Configures if the proxy should add itself to `X-Forwarded-For` list or start a new one.
`:proxy-max-connection-retries`:: int, defaults to 1.
`:proxy-max-request-time`:: ms as int, defaults to 30000. 30sec request timeout.


== JVM Configuration [[jvm-opts]]

When `shadow-cljs.edn` is used in charge of starting the JVM you can configure additional command line arguments to be passed directly to the JVM. For example you may want to decrease or increase the amount of RAM used by shadow-cljs.

This is done by configuring `:jvm-opts` at the root of `shadow-cljs.edn` expecting a vector of strings.

.Example limited RAM use to 1GB
```clojure
{:source-paths [...]
 :dependencies [...]
 :jvm-opts ["-Xmx1G"]
 :builds ...}
```

The arguments that can be passed to the JVM vary depending on the version but you can find an example list https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html[here]. Please note that assigning too little or too much RAM can degrade performance. The defaults are usually good enough.

IMPORTANT: When using `deps.edn` or `project.clj` the `:jvm-opts` need to be configured there.

= Build Configuration

include::build-config.adoc[]

= Targeting the Browser [[target-browser]]

include::target-browser.adoc[]

= Targeting React Native [[target-react-native]]

include::target-react-native.adoc[]

= Targeting node.js [[target-node]]

There is built-in support for generating code that is intended to be used as a stand-alone
script, and also for code that is intended to be used as a library. See the
section on <<config,common configuration>> for the base settings needed in
a configuration file.

== node.js Scripts [[target-node-script]]

include::target-node-script.adoc[]

== node.js Libraries [[target-node-library]]

include::target-node-library.adoc[]


== Creating `npm` packages

// TODO: Thomas: I think it would be useful to show a package.json and a little bit of an example
// on how you could set up to deploy this on NPM.

= Embedding in the JS Ecosystem -- The `:npm-module` Target [[target-npm-module]]

include::target-npm-module.adoc[]

= Testing

`shadow-cljs` provides a few utility targets to make building tests a little easier.

All test targets generate a test runner and automatically add all namespaces matching the configurable `:ns-regexp`. The default test runners were built for `cljs.test` but you can create custom runners if you prefer to use other test frameworks.

The default `:ns-regexp` is `"-test$"`, so your first test could look like:

.File: `src/test/demo/app_test.cljs`
```clojure
(ns demo.app-test
  (:require [cljs.test :refer (deftest is)]))

(deftest a-failing-test
  (is (= 1 2)))
```

In the Clojure world it is common to keep test files in their own source paths so the above example assumes you have configured `:source-paths ["src/main" "src/test"]` in your `shadow-cljs.edn` config. Your usual app code goes into `src/main` and the tests go into `src/test`. This however is optional and it is totally fine to keep everything in `src` and just use `:source-paths ["src"]`.

== Testing in node.js [[target-node-test]]

include::target-node-test.adoc[]

== Testing in the Browser [[target-browser-test]]

include::target-browser-test.adoc[]

== Targeting Tests to Karma for Continuous Integration [[target-karma]]

include::target-karma.adoc[]

= JavaScript Integration [[js-deps]]

include::js-deps.adoc[]

= Generating Production Code -- All Targets [[release]]

include::release.adoc[]

= Editor Integration

include::editor-integration.adoc[]

include::repl-troubleshoot.adoc[]

include::maven-publish.adoc[]

= What to do when things don’t work?

Since the JS world is still evolving rapidly and not everyone is using the same way to write and
distribute code there are some things `shadow-cljs` cannot work around automatically. These
can usually be solved with custom `:resolve` configs, but there may also be bugs or oversights.

If you cannot resolve such an issue with the instructions in this chapter, then try asking on the
https://clojurians.slack.com/messages/C6N245JGG[`#shadow-cljs` Slack channel].

= Hacking

== Patching Libraries

The `shadow-cljs` compiler ensures that things on your source paths are compiled first, overriding files from JARs. This means that you can copy a source file from a library, patch it, and include it in your own source directory.

This is a convenient way to test out fixes (even to `shadow-cljs` itself!) without having to clone
that project and understand its setup, build, etc.
