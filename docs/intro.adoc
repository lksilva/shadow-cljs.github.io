= Introdução

`shadow-cljs` provê tudo que você precisa pra compilar seu projeto ClojureScript com foco em simplicidade e facilidade de uso. A compilação do build fornecidos abstraem a maioria da configuração manual de modo que a única coisa que você tem que fazaer é configurar coisas essenciais para o seu build. Cada target provê padrões ótimos para cada ambiente e fornece uma experiência otimizada durante a fase de desenvolvimento e builds de produção.

== Visão de auto nível

`shadow-cljs` é composto de duas partes:

- A https://clojars.org/thheller/shadow-cljs[shadow-cljs] biblioteca Clojure que manipula todo o trabalho atual.
- O https://www.npmjs.com/package/shadow-cljs[shadow-cljs], pacote `npm` que fornece uma interface coviciente para rodar a maioria das funcionalidades de build diretamente da linha de comando.

É possivel integrar facilmente a biblioteca Clojure `shadow-cljs` em qualquer outro ferramenta de compilação Clojure/JVM (eg. https://leiningen.org/[leiningen] ou a ferramenta https://clojure.org/guides/deps_and_cli[Clojure CLI]).

É recomendado usar os pacotes `npm` que fornece uma experiência mais otimizada e sob medida em relação ao desenvolvimento com CLJS.

== Fluxo de trabalho básico 

When trabalhando com `shadow-cljs` você definirá uma ou mais builds no arquivo de configuração `shadow-cljs.edn`. Cada build tem a propriedade `:target` que representa uma configuração otimizada e predefinida para o ambiente alvo (eg. the Browser, uma aplicação `node.js` ou uma Extensão Chrome).

Cada buila pode produzir uma saída de desenvolvimento ou de produção dependendo do comando usado para disparar a compilação. Os padrões de build são: `compile`, `watch` e `release`.

=== Modo de desenvolvimento

É possível `compile` uma build de desenvolvimento uma vez ou rodar o processo `watch` que vai monitorar seus arquivos e recompilar eles automáticamente (e live-reload o code se você desejar).

Todas as builds de desenvolvimento são otimizadas para experiência do desenvolvedor, com ciclos de feedback rápido e outras funcionalidades como REPL para interagir diretamente com o código rodando.

Uma build de desenvolvimento nunca deveria ser públicada desde que ela pode torna-se um pouco grande e deve funcionar apenas na máquina onde foi compilada, dependendo do `:target`.

=== Modo de produção

Criando uma build de `release` vai remover todo o código relacionado ao modo de desenvolvimento e finalmente roda o código atráves do Closure Compiler. Esse é um Compiler otimizado para JavaScript que reduz significativamente no geral o tamanho do código.


== Conceitos importantes

Existe vários conceitos importantes que você deveria estar familiarizado quando usando `shadow-cljs`. Eles são fundamentais para o entendimento de como tudo se encaixa junto e como a ferramenta trabalha com o código.

=== O Classpath

`shadow-cljs` usa a Java Virtual Machine (JVM) e o "classpath" quando trabalhando com arquivos. Esse é o filesystem virtual composto de muitas entidades classpath. Cada entidade é

- A local filesystem directory, managed by `:source-paths` entry in the configuration.
- Or a `.jar` file, representing Clojure(Script) or JVM libraries. These are compressed archives containing many files (basically just a `.zip` file). These are added by your `:dependencies`.

In the Clojure(Script) everything is namespaced and each name is expected to resolve to a file. If you have a `(ns demo.app)` namespace the compiler expects to find a `demo/app.cljs` (or `.cljc`) on the classpath. The classpath will be searched in order until it is found. Suppose you configured the `:source-paths ["src/main" "src/test"]` the compiler will first look for a `src/main/demo/app.cljs` and then `src/test/demo/app.cljs`. When the file is not found on any source path the JVM will begin looking into the `.jar` files on the classpath. When it finds a `demo/app.cljs` at the root of any of the libraries that file it will be used.

IMPORTANT: When a filename exists multiple times on the classpath then only the first one is used. Everything on the JVM and Clojure(Script) is namespaced to avoid such conflicts. Very similar to `npm` where each package must have a unique name.

It is therefore recommended to be very disciplined about the names you choose and properly namespacing everything. It may seem repetitive to always use `(ns your-company.components.foo)` over `(ns components.foo)` but it will save you from lot of headaches later on.

This is unlike `npm` where the package name itself is never used inside the package itself and only relative paths are used.


=== Server Mode

`shadow-cljs` can be started in "server" mode which is required for long-running tasks such as `watch`. A `watch` will implicitly start the server instance if it is not already running. The server will provide the Websocket endpoint that builds will connect to as well as all the other endpoints for nREPL, Socket REPL and the development HTTP servers.

When using the `shadow-cljs` CLI interface all commands will re-use a running server instance JVM instead of starting a new JVM. This is substantially faster since start-up time can be quite slow.

Once the server is running however you only have to restart it whenever your `:dependencies` change and everything else can be done via the REPL.

=== REPL

The REPL is at the heart of all Clojure(Script) development and every CLI command can also be used directly from the REPL as well. It is absolutely worth getting comfortable with the REPL even if the command line may seem more familiar.
